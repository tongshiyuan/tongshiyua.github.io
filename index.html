<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Taro">
<meta property="og:url" content="http://tongshiyuan.github.io/index.html">
<meta property="og:site_name" content="Taro">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Taro">



  <link rel="alternate" href="/atom.xml" title="Taro" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://tongshiyuan.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Taro</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/tongshiyuan" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Taro</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/09/22/WGS分析笔记（6）- call CNV 和一些其他/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/22/WGS分析笔记（6）- call CNV 和一些其他/" class="post-title-link" itemprop="url">WGS分析笔记（6）- call CNV 和一些其他</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-22 19:33:47 / 修改时间：21:27:06" itemprop="dateCreated datePublished" datetime="2019-09-22T19:33:47+08:00">2019-09-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS/" itemprop="url" rel="index"><span itemprop="name">我的WGS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>CNVs（copy number variations）是除了SNVs、INDELs之外另一种可能导致孟德尔遗传疾病的变异类型，指的是大片段（1kb到几个Mb）的碱基出现拷贝数的变异（del、dup等）。</p>
</li>
<li><p>目前常用的关于CNVs的数据库有DGV、DECIPHER等，以下链接可供参考。</p>
<ul>
<li>健康人群 CNV： Genomic Variants  <a href="http://www.projects.tcag.ca/variation" target="_blank" rel="noopener">www.projects.tcag.ca/variation</a></li>
<li>神经发育异常的患者 CNVs： DECIPHER  <a href="http://www.sanger.ac.uk/PostGenomic/decipher/" target="_blank" rel="noopener">www.sanger.ac.uk/PostGenomic/decipher/</a></li>
<li>染色体异常的患者 CNVs： <a href="http://www.ukcad.org.uk/cocoon/ukcad、www.isca.genetics.emory.edu/" target="_blank" rel="noopener">www.ukcad.org.uk/cocoon/ukcad、www.isca.genetics.emory.edu/</a></li>
<li>染色体非平衡变异的患者 CNVs： <a href="http://www.ecaruca.net" target="_blank" rel="noopener">www.ecaruca.net</a></li>
</ul>
</li>
<li><p>目前临床上对于CNVs的检测一般有CMA、MLPA、CNV-se、aCGH等技术，但是对于WES、WGS的数据也可以使用软件进行call CNVs。</p>
</li>
<li><p>目前有很多进行call CNVs的软件，本文主要记录cnvnator的安装和使用。</p>
</li>
<li><p>cnvnator相关文章发表在2011年的《Genome research》上，而相关的软件也挂在了github上，网址如下：<a href="https://github.com/abyzovlab/CNVnator" target="_blank" rel="noopener">https://github.com/abyzovlab/CNVnator</a></p>
</li>
<li><p>cnvnator最大的一个缺点就是安装十分不便，和其他软件相比，这基本上是最被大家吐槽的一点，其次是运行所占内存也是较大的。</p>
</li>
<li><p>当然你可以选择现成的docker使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull diploid/cnvnator</span><br></pre></td></tr></table></figure>
</li>
<li><p>我这里记录并分享一下我的使用经历包括安装经历。</p>
</li>
<li><p>首先是安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 笔者是作为管理员在Root的权限下安装的，可以在个人用户下安装</span><br><span class="line"># 首先是root的安装，root可以理解为一个软件，也是cnvnator所依赖的</span><br><span class="line">$ git clone https://github.com/root-project/root.git</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ../root</span><br><span class="line">$ make -j 4</span><br><span class="line">$ source bin/thisroot.sh</span><br><span class="line"># 这里提醒一下，笔者安装过多次root，各种版本的，新的、旧的，无一都失败了，只有上述这个成功了</span><br><span class="line"># 接下来就是CNVnator的安装，</span><br><span class="line">$ git clone https://github.com/abyzovlab/CNVnator.git</span><br><span class="line">$ cd CNVnator</span><br><span class="line"># 此处的用你的samtools安装位置在CNVnator目录下建立软链接</span><br><span class="line">$ ln -s /your/path/of/samtools-1.9/ samtools</span><br><span class="line"># 安装依赖包yeppp</span><br><span class="line">$ mkdir yeppp &amp;&amp; cd yeppp</span><br><span class="line">$ wget http://bitbucket.org/MDukhan/yeppp/downloads/yeppp-1.0.0.tar.bz2</span><br><span class="line">$ tar xjf yeppp-1.0.0.tar.bz2</span><br><span class="line">$ make clean</span><br><span class="line">$ make LIBS=&quot;-lcrypto&quot;</span><br><span class="line"># 此处将root软件加入变量中</span><br><span class="line">$ vim .bashrc</span><br><span class="line">加入：export LD_LIBRARY_PATH=/your/path/of/root/build/lib:$LD_LIBRARY_PATH</span><br><span class="line">$ source .bashrc</span><br><span class="line"># 到这里就安装完了，你也可以建立一个软链接把cnvnator链接到bin目录下，这样就可以直接用cnvnator作为命令</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到安装还是很麻烦的，笔者也是安装了N次才成功，都快崩溃的那种。</p>
</li>
<li><p>接下来是使用记录，使用还是很方便的，可以安装github的说明一步一步来，没有什么太难的地方，这里稍微记录一下并介绍个别参数。</p>
</li>
<li><p>以我自己的数据为例，我的是生殖细胞系的WGS数据，输入文件是已经比对完的bam文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cnvnator -root sample.root -tree /your/path/of/bam</span><br><span class="line">$ cnvnator -root sample.root -his 100 -d /your/path/of/hg19</span><br><span class="line">$ cnvnator -root sample.root -stat 100</span><br><span class="line">$ cnvnator -root sample.root -partition 100</span><br><span class="line">$ cnvnator -root sample.root -call 100 &gt; sample.cnvnator</span><br><span class="line">$ awk &apos;&#123; print $2 &#125; END &#123; print &quot;exit&quot; &#125;&apos; sample.cnvnator | cnvnator -root sample.root -genotype 100 &gt; sample.gt</span><br><span class="line">$ /your/path/of/CNVnator/cnvnator2VCF.pl -prefix sample -reference hg19 sample.cnvnator /your/path/of/hg19 &gt; sample.vcf</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面就是常规步骤了，介绍几个点：</p>
<ul>
<li><p>首先是 -his 参数的值，也就是bin_size的值，这个可以根据CNVnator作者的建议，根据测序深度的不同进行调整：100X: 30；20-30X: 100；4-6X: 500；再低就1000</p>
</li>
<li><p>其次是 -d 参数，关于这个参数，官网有两种用法：</p>
<ol>
<li>如果使用 -d 那就后面接参考基因组所在目录，作者自己是在 hg19 下有各个不同染色体的fasta文件，虽然按照说明是只要目录下有参考基因组就行了。这里笔者一开始目录中只有合并后的hg19的文件，发现下面的步骤报错，后来就重新下载hg19文件，解压后没有合并，运行正常。</li>
<li>如果使用 -fasta 参数就在后面跟参考基因组的压缩文件，笔者是把 hg19.fa 压缩成了 hg19.fa.gz ，但是后面还是报错了</li>
</ol>
</li>
<li><p>第六句<code>awk</code>那一句可以不运行，主要是看genotype，不影响最后一步转换为vcf文件</p>
</li>
</ul>
</li>
<li><p>到这一步其实也就差不多了，那么下面是关于CNVs数据的一些简单处理方式和意见的记录，这一块笔者也没有仔细去研究，如果有需要可以单独交流。</p>
</li>
<li><p>关于CNV结果的注释，这里参考annovar注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ perl convert2annovar.pl -format vcf4old sample.vcf &gt; sample.avinput</span><br><span class="line">$ perl table_annovar.pl W001.avinput /your/path/of/annovar/humandb/ --buildver hg19 -remove -out sample -protocol refGene,cytoBand,omim201806,gwasCatalog,CCRS,phastConsElements100way,phastConsElements46way,phastConsElements46wayPlacental,phastConsElements46wayPrimates,tfbsConsSites,rmsk,dgvMerged,HIP,Constraint -operation g,r,r,r,r,r,r,r,r,r,r,r,r,r -nastring . --thread 12</span><br></pre></td></tr></table></figure>
</li>
<li><p>其实对于 CNVs 的注释和筛选，所能使用的数据库并不像 SNVs 那么多，所幸的是CNVs的结果也没那么多。</p>
</li>
<li><p>上面注释所涉及的数据库大多数能在annovar中直接下载，除了omim201806、CCRS、HIP、Constraint。</p>
<ul>
<li><p>OMIM的数据可以在OMIM官网通过申请下载，这里不方便挂出来，不过笔者最近一次申请都过去几个月了，OMIM还是没有把链接发过来。</p>
</li>
<li><p>CCRS的数据可以在笔者之前的文章，关于注释的那一篇中下载并修改格式，但是用在CNVs中参考价值可能不大，可自行查阅。</p>
</li>
<li><p>HIP和Constraint的数据来源于DECIPHER，可以作为参考，下面记录一下如何下载并转换格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># DECIPHER数据库提供了在线的可视化的检索方式，可以查看相关变异的很多信息，包括表型、致病性等，这些信息都是临床或科研单位上传的。其中DECIPHER可供下载的数据包括以下三种</span><br><span class="line"># Haploinsufficiency Predictions:</span><br><span class="line">#    Updated predictions of haploinsufficiency as described by Huang et al. (2010, PLoS Genetics). Available as a Bed file for download from the link above.</span><br><span class="line">$ wget https://decipher.sanger.ac.uk/files/downloads/HI_Predictions_Version3.bed.gz</span><br><span class="line"># Population Copy-Number Variation Frequencies</span><br><span class="line">#    Common copy-number variants and their frequencies, as used and displayed in DECIPHER.</span><br><span class="line">$ wget https://decipher.sanger.ac.uk/files/downloads/population_cnv.txt.gz</span><br><span class="line"># Development Disorder Genotype – Phenotype Database (DDG2P) </span><br><span class="line">#    a curated list of genes reported to be associated with developmental disorders, compiled by clinicians as part of the DDD study to facilitate clinical feedback of likely causal variants. Please note: This file is maintained by the European Bioinformatics Institute. Its contents may differ from DECIPHER due to different update cycles.</span><br><span class="line">$ wget http://www.ebi.ac.uk/gene2phenotype/downloads/DDG2P.csv.gz</span><br><span class="line"># 上面是下载了三个数据库，当然下面只用到了两个，还有一个频率数据库笔者也不知道怎么去注释和使用比较好</span><br><span class="line"># 上述三个数据库直接用gunzip去解压就行</span><br><span class="line"># pLI:</span><br><span class="line">	$ awk -F &quot;\t&quot; &apos;&#123;print 0&quot;\t&quot;$3&quot;\t&quot;$5&quot;\t&quot;$6&quot;\t&quot;$20&#125;&apos; Constraint.txt &gt; hg19_Constraint.txt</span><br><span class="line">	$ sed -i &apos;1d&apos; hg19_Constraint.txt</span><br><span class="line"># HIP:</span><br><span class="line">	$ sed -i &apos;1d&apos; HI_Predictions_Version3.bed </span><br><span class="line">	$ bedtools sort -i HI_Predictions_Version3.bed &gt; HIP.txt</span><br><span class="line">	$ awk -F &quot;\t&quot; &apos;&#123;print 0&quot;\t&quot;$1&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t&quot;$4&#125;&apos; HIP.txt &gt; hg19_HIP.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后记得把两个数据库放到 humandb 目录下。</p>
</li>
<li><p>DECIPHER有对这两个数值进行介绍</p>
<ul>
<li><p>HIP，参考<a href="https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1001154" target="_blank" rel="noopener">paper</a></p>
<p><img src="/2019/09/22/WGS分析笔记（6）- call CNV 和一些其他/1.png" alt="1569157836561"></p>
</li>
<li><p>pLI，参考<a href="https://www.nature.com/articles/nature19057" target="_blank" rel="noopener">paper</a></p>
<p><img src="/2019/09/22/WGS分析笔记（6）- call CNV 和一些其他/2.png" alt="1569157975971"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>除此之外，对于CNVs的研究也可以考虑从trio样本出发。考虑思路和snv类似，就是从遗传模式考虑，比如患者父母正常的情况下，可以寻找de novo、AR类型的变异。还有就是可以考虑将CNV的数据结合SNV/INDEL一起分析，主要就是CNV可能与SNV/INDEL构成复合杂合等情况。当然这些都是一些思路。</p>
<hr>
<p>水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/07/26/python-numpy学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/26/python-numpy学习笔记/" class="post-title-link" itemprop="url">python: numpy学习笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-26 10:08:55 / 修改时间：10:14:54" itemprop="dateCreated datePublished" datetime="2019-07-26T10:08:55+08:00">2019-07-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python学习笔记/" itemprop="url" rel="index"><span itemprop="name">python学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="列表与array的区别"><a href="#列表与array的区别" class="headerlink" title="列表与array的区别"></a>列表与array的区别</h3><ul>
<li>在实现层面，数组基本上包含一个指向连续数据块的指针。另一方面，Python列表包含一个指向指针块的指针，这其中的每一个指针对应一个完整的Python对象。另外，列表的优势是灵活，因为每个列表元素是一个包含数据和类型信息的完整结构体，而且列表可以用任意类型的数据填充。固定类型的NumPy式数组缺乏这种灵活性，但是能更有效地存储和操作数据。</li>
</ul>
<h3 id="导入numpy"><a href="#导入numpy" class="headerlink" title="导入numpy"></a>导入numpy</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h3 id="array的创建"><a href="#array的创建" class="headerlink" title="array的创建"></a>array的创建</h3><h4 id="从列表创建数组"><a href="#从列表创建数组" class="headerlink" title="从列表创建数组"></a>从列表创建数组</h4><ul>
<li>通过 list 创建一维 array</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">nd1 = np.array(list1)</span><br><span class="line">print(nd1)</span><br><span class="line">print(type(nd1))</span><br></pre></td></tr></table></figure>

<pre><code>[1 3 5 7]
&lt;class &apos;numpy.ndarray&apos;&gt;</code></pre><ul>
<li>通过 list 创建二维 array</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>]]</span><br><span class="line">nd2 = np.array(list2)</span><br><span class="line">print(nd2)</span><br><span class="line">print(type(nd2))</span><br></pre></td></tr></table></figure>

<pre><code>[[1 2 4 8]
 [4 5 9 3]]
&lt;class &apos;numpy.ndarray&apos;&gt;</code></pre><ul>
<li>如果需要明确数组的数据类型，可以用<code>dtype</code>关键字</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="string">'float32'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([1., 3., 4.], dtype=float32)</code></pre><h4 id="从头创建数组"><a href="#从头创建数组" class="headerlink" title="从头创建数组"></a>从头创建数组</h4><ul>
<li>通过范围创建 array</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性序列</span></span><br><span class="line"><span class="comment"># 从10开始，1结束（不包含），步长为-1</span></span><br><span class="line"><span class="comment"># arange([start,]stop[,step],dtype=None)</span></span><br><span class="line">np.arange(<span class="number">10</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([10,  9,  8,  7,  6,  5,  4,  3,  2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建五个元素的数组，这5个数均匀地分配到0-1</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([0.  , 0.25, 0.5 , 0.75, 1.  ])</code></pre><ul>
<li>生成特殊矩阵</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全零矩阵</span></span><br><span class="line">np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">np.zeros(<span class="number">5</span>, dtype=int)</span><br></pre></td></tr></table></figure>

<pre><code>array([0, 0, 0, 0, 0])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全一矩阵</span></span><br><span class="line">np.ones((<span class="number">4</span>,<span class="number">4</span>), dtype=float)</span><br><span class="line">np.ones(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([1., 1., 1., 1., 1.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认值一直的矩阵</span></span><br><span class="line">np.full((<span class="number">3</span>, <span class="number">5</span>), <span class="number">3.4</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([[3.4, 3.4, 3.4, 3.4, 3.4],
       [3.4, 3.4, 3.4, 3.4, 3.4],
       [3.4, 3.4, 3.4, 3.4, 3.4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单位矩阵</span></span><br><span class="line">np.eye(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对角线矩阵</span></span><br><span class="line">np.diag([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个由3个整型数组成的未初始化的数组</span></span><br><span class="line"><span class="comment"># 数组的值是内存空间中的任意值</span></span><br><span class="line">np.empty(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([1., 1., 1.])</code></pre><ul>
<li>生成随机数组<ul>
<li>random生成0到1之间的随机数</li>
<li>uniform生成均匀分布随机数</li>
<li>randn生成标准正态的随机数</li>
<li>normal生成正态分布</li>
<li>shuffle随机打乱顺序</li>
<li>seed设置随机种子数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设计随机种子</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个3*3、在0-1均匀分布的随机数组成的数组</span></span><br><span class="line">x = np.random.random((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[[0.69646919 0.28613933 0.22685145]
 [0.55131477 0.71946897 0.42310646]
 [0.9807642  0.68482974 0.4809319 ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打乱随机数</span></span><br><span class="line">np.random.shuffle(x)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[[0.9807642  0.68482974 0.4809319 ]
 [0.69646919 0.28613933 0.22685145]
 [0.55131477 0.71946897 0.42310646]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个3*3的、均值为0，方差为1的正态分布的随机数数组</span></span><br><span class="line">np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<pre><code>array([[ 1.26593626, -0.8667404 , -0.67888615],
       [-0.09470897,  1.49138963, -0.638902  ],
       [-0.44398196, -0.43435128,  2.20593008]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个3*3，[0, 10)区间的随机整型数组</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<pre><code>array([[8, 0, 7],
       [9, 3, 4],
       [6, 1, 5]])</code></pre><h3 id="Numpy数据类型"><a href="#Numpy数据类型" class="headerlink" title="Numpy数据类型"></a>Numpy数据类型</h3><h4 id="指定方式"><a href="#指定方式" class="headerlink" title="指定方式"></a>指定方式</h4><ul>
<li><p>字符串</p>
<p>  <code>dtype=&#39;int16&#39;</code></p>
</li>
<li><p>numpy对象</p>
<p>  <code>dtype=np.int16</code></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4></li>
<li><p>数据类型:描述</p>
<ul>
<li>bool_:布尔值（真、True 或假、False），用一个字节存储</li>
<li>int_ : 默认整型（类似于 C 语言中的 long，通常情况下是 int64 或 int32）</li>
<li>intc_ : 同 C 语言的 int 相同（通常是 int32 或 int64）</li>
<li>intp : 用作索引的整型（和 C 语言的 ssize_t 相同，通常情况下是 int32 或 int64）</li>
<li>int8 : 字节（byte，范围从–128 到 127）</li>
<li>int16 : 整型（范围从–32768 到 32767）</li>
<li>int32 : 整型（范围从–2147483648 到 2147483647）</li>
<li>int64 : 整型（范围从–9223372036854775808 到 9223372036854775807）</li>
<li>uint8 : 无符号整型（范围从 0 到 255）</li>
<li>uint16 : 无符号整型（范围从 0 到 65535）</li>
<li>uint32 : 无符号整型（范围从 0 到 4294967295）</li>
<li>uint64 : 无符号整型（范围从 0 到 18446744073709551615）</li>
<li>float_ : float64 的简化形式</li>
<li>float16 : 半精度浮点型：符号比特位，5 比特位指数（exponent），10 比特位尾数（mantissa）</li>
<li>float32 : 单精度浮点型：符号比特位，8 比特位指数，23 比特位尾数</li>
<li>float64 : 双精度浮点型：符号比特位，11 比特位指数，52 比特位尾数</li>
<li>complex_ : complex128 的简化形式</li>
<li>complex64 : 复数，由两个 32 位浮点数表示</li>
<li>complex128 : 复数，由两个 64 位浮点数表示</li>
</ul>
</li>
</ul>
<h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shape</span></span><br><span class="line">nd2.shape</span><br></pre></td></tr></table></figure>

<pre><code>(2, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size 元素的个数</span></span><br><span class="line">nd2.size</span><br></pre></td></tr></table></figure>

<pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据类型</span></span><br><span class="line">nd2.dtype</span><br></pre></td></tr></table></figure>

<pre><code>dtype(&apos;int32&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的维度</span></span><br><span class="line">nd2.ndim</span><br></pre></td></tr></table></figure>

<pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个数组元素字节大小</span></span><br><span class="line">nd2.itemsize</span><br></pre></td></tr></table></figure>

<pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组总字节大小</span></span><br><span class="line"><span class="comment"># 一般认为 nbytes 跟 itemsize 和 size 的乘积大小相等</span></span><br><span class="line">nd2.nbytes</span><br></pre></td></tr></table></figure>

<pre><code>32</code></pre><h3 id="数据的索引"><a href="#数据的索引" class="headerlink" title="数据的索引"></a>数据的索引</h3><h4 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><ul>
<li><p>对于一维数组，直接通过中括号指定索引获取第i个值（从0开始计数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用负值索引末尾索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[-1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组中，可以用逗号分隔的索引元组获取元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[2, -1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用以上索引方式修改元素值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[0, 0] = 12</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>NumPy 数组是固定类型的。这意味着当你试图将一个浮点值插入一个整型数组时，浮点值会被截短成整型。并且这种截短是自动完成的，不会给你提示或警告，所以需要特别注意这一点！</li>
</ul>
<h3 id="数据的切片"><a href="#数据的切片" class="headerlink" title="数据的切片"></a>数据的切片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[start:stop:step]</span><br></pre></td></tr></table></figure>

<ul>
<li>当上述参数均未指定，那么缺省值为：<code>start = 0</code>、<code>stop = 维度的大小（size of dimension）</code> 和 <code>step = 1</code><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">x[:<span class="number">5</span>] <span class="comment"># 前五个元素</span></span><br></pre></td></tr></table></figure>

<pre><code>array([0, 1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">5</span>:] <span class="comment"># 索引5以后的元素</span></span><br></pre></td></tr></table></figure>

<pre><code>array([5, 6, 7, 8, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">4</span>:<span class="number">7</span>] <span class="comment"># 索引4到6</span></span><br></pre></td></tr></table></figure>

<pre><code>array([4, 5, 6])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[::<span class="number">2</span>] <span class="comment"># 隔一个元素</span></span><br></pre></td></tr></table></figure>

<pre><code>array([0, 2, 4, 6, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[::<span class="number">-1</span>] <span class="comment"># 逆序取所有元素</span></span><br></pre></td></tr></table></figure>

<pre><code>array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">5</span>::<span class="number">-2</span>] <span class="comment"># 从索引5隔一个逆序</span></span><br></pre></td></tr></table></figure>

<pre><code>array([5, 3, 1])</code></pre><h4 id="多维子数组"><a href="#多维子数组" class="headerlink" title="多维子数组"></a>多维子数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x2 = np.array([range(<span class="number">1</span> + i, <span class="number">5</span> + i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">x2[:<span class="number">2</span>, :<span class="number">3</span>] <span class="comment"># 两行三列</span></span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 2, 3],
       [2, 3, 4]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2[:, ::<span class="number">2</span>] <span class="comment"># 所有行，隔一列</span></span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 3],
       [2, 4],
       [3, 5],
       [4, 6],
       [5, 7]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2[::<span class="number">-1</span>, ::<span class="number">-1</span>] <span class="comment"># 逆序</span></span><br></pre></td></tr></table></figure>

<pre><code>array([[8, 7, 6, 5],
       [7, 6, 5, 4],
       [6, 5, 4, 3],
       [5, 4, 3, 2],
       [4, 3, 2, 1]])</code></pre><h4 id="行、列获取"><a href="#行、列获取" class="headerlink" title="行、列获取"></a>行、列获取</h4><ul>
<li>一个冒号（:）表示空切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2[:, <span class="number">1</span>] <span class="comment"># 第二列</span></span><br></pre></td></tr></table></figure>

<pre><code>array([2, 3, 4, 5, 6])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2[<span class="number">1</span>, :] <span class="comment"># 第二行</span></span><br></pre></td></tr></table></figure>

<pre><code>array([2, 3, 4, 5])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2[<span class="number">1</span>] <span class="comment"># 行的简便写法</span></span><br></pre></td></tr></table></figure>

<pre><code>array([2, 3, 4, 5])</code></pre><h4 id="非副本视图的子数组"><a href="#非副本视图的子数组" class="headerlink" title="非副本视图的子数组"></a>非副本视图的子数组</h4><ul>
<li>是数组切片返回的是数组数据的视图，而不是数值数据的副本</li>
<li>意思就是说，当修改子数组的数据时，原数据也会被修改</li>
<li>它意味着在处理非常大的数据集时，可以获取或处理这些数据集的片段，而不用复制底层的数据缓存</li>
</ul>
<h4 id="创建数组的副本"><a href="#创建数组的副本" class="headerlink" title="创建数组的副本"></a>创建数组的副本</h4><p>通过<code>copy()</code>来完成复制数组里的数据或者子数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_sub = x2[:2, :2].copy()</span><br></pre></td></tr></table></figure>

<h3 id="数据的变形"><a href="#数据的变形" class="headerlink" title="数据的变形"></a>数据的变形</h3><p>通过<code>reshape()</code>实现数组变形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(1, 10).reshape((3, 3))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>原始数组的大小和变形后数组的大小一致</p>
</li>
<li><p>如果不能保证上述条件，<code>-1</code>表示自动填充位置的维度</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(1, 10).reshape((3, -1))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用newaxis将一个一维数组转变为二维的行或列的矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 行矩阵</span><br><span class="line">x[np.newaxis, :]</span><br><span class="line"># 列矩阵</span><br><span class="line">x[:, np.newaxis]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组的拼接和分裂"><a href="#数组的拼接和分裂" class="headerlink" title="数组的拼接和分裂"></a>数组的拼接和分裂</h3><h4 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h4><ul>
<li><code>np.concatenate</code><ul>
<li>以<code>数组元组或数组列表</code>作为第一个参数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拼接两个数组</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">np.concatenate([x, y])</span><br></pre></td></tr></table></figure>

<pre><code>array([1, 2, 3, 3, 2, 1])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拼接多个数组</span></span><br><span class="line">z = [<span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>]</span><br><span class="line">np.concatenate([x, y, z])</span><br></pre></td></tr></table></figure>

<pre><code>array([ 1,  2,  3,  3,  2,  1, 11, 11, 11])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维数组拼接</span></span><br><span class="line"><span class="comment"># 按第一个轴拼接，上下拼接</span></span><br><span class="line">grid = np.array([range(<span class="number">1</span> + i, <span class="number">5</span> + i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">np.concatenate([grid, grid])</span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 2, 3, 4],
       [2, 3, 4, 5],
       [3, 4, 5, 6],
       [1, 2, 3, 4],
       [2, 3, 4, 5],
       [3, 4, 5, 6]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按第二个轴拼接，左右拼接</span></span><br><span class="line">np.concatenate([grid, grid], axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 2, 3, 4, 1, 2, 3, 4],
       [2, 3, 4, 5, 2, 3, 4, 5],
       [3, 4, 5, 6, 3, 4, 5, 6]])</code></pre><ul>
<li><code>np.vstack</code> 垂直栈</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vstack([x, y])</span><br></pre></td></tr></table></figure>

<pre><code>array([[1, 2, 3],
       [3, 2, 1]])</code></pre><ul>
<li><code>np.hstack</code> 水平栈</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack([x, y])</span><br></pre></td></tr></table></figure>

<pre><code>array([1, 2, 3, 3, 2, 1])</code></pre><ul>
<li><code>np.dstack</code> 沿着第三个维度拼接数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dstack([x, y])</span><br></pre></td></tr></table></figure>

<pre><code>array([[[1, 3],
        [2, 2],
        [3, 1]]])</code></pre><h4 id="数组的分裂"><a href="#数组的分裂" class="headerlink" title="数组的分裂"></a>数组的分裂</h4><ul>
<li>与拼接相反的过程，通过<code>np.split</code>、<code>np.hsplit</code>和<code>np.vsplit</code>来实现</li>
<li>传递一个索引列表作为参数，索引列表记录的是分裂点位置</li>
<li>N个分裂点会得到 N + 1 个子数组</li>
</ul>
<p><code>np.split</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">np.split(x, [<span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<pre><code>[array([1, 2, 3]), array([4, 5]), array([6, 7])]</code></pre><p><code>np.vsplit()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid = np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>,<span class="number">-1</span>))</span><br><span class="line">np.vsplit(grid, [<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<pre><code>[array([[0, 1, 2, 3],
        [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],
        [12, 13, 14, 15]])]</code></pre><p><code>np.hsplit()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(grid, [<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<pre><code>[array([[ 0,  1],
        [ 4,  5],
        [ 8,  9],
        [12, 13]]), array([[ 2,  3],
        [ 6,  7],
        [10, 11],
        [14, 15]])]</code></pre><p><code>np.dsplit()</code></p>
<ul>
<li>数组沿着第三个维度分裂<h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3></li>
</ul>
<ul>
<li>向量操作<ul>
<li>通过简单地对数组执行操作来实现，这里对数组的操作将会被用于数组中的每一个元素</li>
</ul>
</li>
</ul>
<h4 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h4><table>
<thead>
<tr>
<th align="right">运算符</th>
<th align="right">通用函数</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="right">+</td>
<td align="right">np.add</td>
<td align="right">加法</td>
</tr>
<tr>
<td align="right">-</td>
<td align="right">np.subtract</td>
<td align="right">减法</td>
</tr>
<tr>
<td align="right">-</td>
<td align="right">np.negative</td>
<td align="right">负数</td>
</tr>
<tr>
<td align="right">*</td>
<td align="right">np.multiply</td>
<td align="right">乘法</td>
</tr>
<tr>
<td align="right">/</td>
<td align="right">np.divide</td>
<td align="right">除法</td>
</tr>
<tr>
<td align="right">//</td>
<td align="right">np.floor_divide</td>
<td align="right">地板除/求整数</td>
</tr>
<tr>
<td align="right">**</td>
<td align="right">np.power</td>
<td align="right">指数运算</td>
</tr>
<tr>
<td align="right">%</td>
<td align="right">np.mod</td>
<td align="right">模/余数</td>
</tr>
</tbody></table>
<h4 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h4><ul>
<li>可以识别内置abs()函数</li>
<li>对应np.absolute函数</li>
<li>别名np.abs</li>
<li>处理复数时返回复数的幅度<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三角函数</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, np.pi, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">'theta      = '</span>, theta)</span><br><span class="line">print(<span class="string">'sin(theta) = '</span>, np.sin(theta))</span><br><span class="line">print(<span class="string">'cos(theta) = '</span>, np.cos(theta))</span><br><span class="line">print(<span class="string">'tan(theta) = '</span>, np.tan(theta))</span><br></pre></td></tr></table></figure>

<pre><code>theta      =  [0.         1.57079633 3.14159265]
sin(theta) =  [0.0000000e+00 1.0000000e+00 1.2246468e-16]
cos(theta) =  [ 1.000000e+00  6.123234e-17 -1.000000e+00]
tan(theta) =  [ 0.00000000e+00  1.63312394e+16 -1.22464680e-16]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反三角函数</span></span><br><span class="line">x = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">print(<span class="string">'x         = '</span>, x)</span><br><span class="line">print(<span class="string">'arcsin(x) = '</span>, np.arcsin(x))</span><br><span class="line">print(<span class="string">'arccos(x) = '</span>, np.arccos(x))</span><br><span class="line">print(<span class="string">'arctan(x) = '</span>, np.arctan(x))</span><br></pre></td></tr></table></figure>

<pre><code>x         =  [-1, 0, 1]
arcsin(x) =  [-1.57079633  0.          1.57079633]
arccos(x) =  [3.14159265 1.57079633 0.        ]
arctan(x) =  [-0.78539816  0.          0.78539816]</code></pre><h4 id="指数和对数"><a href="#指数和对数" class="headerlink" title="指数和对数"></a>指数和对数</h4><ul>
<li>自然数的指数运算：np.exp</li>
<li>2的指数运算：np.exp2</li>
<li>自定义的指数运算：np.power</li>
<li>自然数为底的对数运算：np.log</li>
<li>2为底的对数运算：np.log2</li>
<li>10为底的对数运算：np.log10</li>
<li>以任意数为底的对数运算：np.log(m)/np.log(n)<ul>
<li>m 为底数</li>
<li>n 为真数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指数运算</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">print(<span class="string">'x    ='</span>, x)</span><br><span class="line">print(<span class="string">'e^x  ='</span>, np.exp(x))</span><br><span class="line">print(<span class="string">'2^x  ='</span>, np.exp2(x))</span><br><span class="line">print(<span class="string">'3^x  ='</span>, np.power(<span class="number">3</span>, x))</span><br></pre></td></tr></table></figure>

<pre><code>x    = [1, 2, 3, 4]
e^x  = [ 2.71828183  7.3890561  20.08553692 54.59815003]
2^x  = [ 2.  4.  8. 16.]
3^x  = [ 3  9 27 81]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对数运算</span></span><br><span class="line">print(<span class="string">'ln(x)    ='</span>, np.log(x))</span><br><span class="line">print(<span class="string">'log2(x)  ='</span>, np.log2(x))</span><br><span class="line">print(<span class="string">'log10(x) ='</span>, np.log10(x))</span><br></pre></td></tr></table></figure>

<pre><code>ln(x)    = [0.         0.69314718 1.09861229 1.38629436]
log2(x)  = [0.        1.        1.5849625 2.       ]
log10(x) = [0.         0.30103    0.47712125 0.60205999]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于非常小的输入值的更好精度计算</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>]</span><br><span class="line">print(<span class="string">'exp(x) - 1 ='</span>, np.expm1(x))</span><br><span class="line">print(<span class="string">'log(1 + x) ='</span>, np.log1p(x))</span><br></pre></td></tr></table></figure>

<pre><code>exp(x) - 1 = [0.         0.0010005  0.01005017 0.10517092]
log(1 + x) = [0.         0.0009995  0.00995033 0.09531018]</code></pre><ul>
<li>logaddexp(a, b)，在计算log(exp(a) + exp(b)) 更准确</li>
</ul>
<h3 id="高级的通用函数特性"><a href="#高级的通用函数特性" class="headerlink" title="高级的通用函数特性"></a>高级的通用函数特性</h3><h4 id="指定输出"><a href="#指定输出" class="headerlink" title="指定输出"></a>指定输出</h4><ul>
<li>在进行大量运算时，有时候指定一个用于存放运算结果的数组是非常有用的。不同于创建临时数组，你可以用这个特性将计算结果直接写入到你期望的存储位置。所有的通用函数都可以通过 out 参数来指定计算结果的存放位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定计算结果的存放位置</span></span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.empty(<span class="number">5</span>)</span><br><span class="line">np.multiply(x, <span class="number">10</span>, out = y)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<pre><code>[ 0. 10. 20. 30. 40.]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入指定数组的每隔一个元素的位置</span></span><br><span class="line">y = np.zeros(<span class="number">10</span>)</span><br><span class="line">np.power(<span class="number">2</span>, x, out=y[::<span class="number">2</span>])</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<pre><code>[ 1.  0.  2.  0.  4.  0.  8.  0. 16.  0.]</code></pre><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul>
<li>reduce：望用一个特定的运算 reduce 一个数组，那么可以用任何通用函数的 reduce 方法。一个 reduce 方法会对给定的元素和操作重复执行，直至得到单个的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">y = np.add.reduce(x)</span><br><span class="line">print(y)</span><br><span class="line">z = np.multiply.reduce(x)</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<pre><code>15
120</code></pre><ul>
<li>accumulate: 存储每次计算的中间结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y = np.add.accumulate(x)</span><br><span class="line">print(y)</span><br><span class="line">z = np.multiply.accumulate(x)</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<pre><code>[ 1  3  6 10 15]
[  1   2   6  24 120]</code></pre><ul>
<li>在一些特殊情况中，NumPy 提供了专用的函数（np.sum、np.prod、np.cumsum、np.cumprod ），它们也可以实现以上 reduce 的功能<h4 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h4></li>
<li>任何通用函数都可以用 outer 方法获得两个不同输入数组所有元素对的函数运算结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y = np.multiply.outer(x, x)</span><br><span class="line">print(y)</span><br><span class="line">z = np.add.outer(x, x)</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<pre><code>[[ 1  2  3  4  5]
 [ 2  4  6  8 10]
 [ 3  6  9 12 15]
 [ 4  8 12 16 20]
 [ 5 10 15 20 25]]
[[ 2  3  4  5  6]
 [ 3  4  5  6  7]
 [ 4  5  6  7  8]
 [ 5  6  7  8  9]
 [ 6  7  8  9 10]]</code></pre><h3 id="聚合：最大值、最小值和其他值"><a href="#聚合：最大值、最小值和其他值" class="headerlink" title="聚合：最大值、最小值和其他值"></a>聚合：最大值、最小值和其他值</h3><ul>
<li>求和<ul>
<li>通过np.sum实现</li>
<li>array.sum()可便捷调用</li>
</ul>
</li>
<li>最大值<ul>
<li>通过np.min实现</li>
<li>array.min()可便捷调用</li>
</ul>
</li>
<li>最小值<ul>
<li>通过np.max实现</li>
<li>array.max()可便捷调用</li>
</ul>
</li>
</ul>
<h4 id="1-多维度聚合"><a href="#1-多维度聚合" class="headerlink" title="1. 多维度聚合"></a>1. 多维度聚合</h4><pre><code>通过指定axis用于沿着某个轴的方向进行聚合。
    * axis = 0 表示每一列，即第一个轴被折叠
    * axis = 1 表示每一行，即第二个轴被折叠</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M = np.random.random((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(M)</span><br><span class="line">print(M.sum())</span><br><span class="line">print(M.min(axis=<span class="number">0</span>))</span><br><span class="line">print(M.max(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[[0.36178866 0.22826323 0.29371405 0.63097612]
 [0.09210494 0.43370117 0.43086276 0.4936851 ]
 [0.42583029 0.31226122 0.42635131 0.89338916]]
5.022928013697376
[0.09210494 0.22826323 0.29371405 0.4936851 ]
[0.63097612 0.4936851  0.89338916]</code></pre><h4 id="2-其他聚合函数"><a href="#2-其他聚合函数" class="headerlink" title="2. 其他聚合函数"></a>2. 其他聚合函数</h4><ul>
<li>大多数的聚合都有对 NaN 值的安全处理策略（NaN-safe），即计算时忽略所有的缺失值，这些缺失值即特殊的 IEEE 浮点型 NaN 值<br></li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数名称</th>
<th align="left">NaN安全版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">np.sum</td>
<td align="left">np.nansum</td>
<td align="left">计算元素的和</td>
</tr>
<tr>
<td align="left">np.prod</td>
<td align="left">np.nanprod</td>
<td align="left">计算元素的积</td>
</tr>
<tr>
<td align="left">np.mean</td>
<td align="left">np.nanmean</td>
<td align="left">计算元素的平均值</td>
</tr>
<tr>
<td align="left">np.std</td>
<td align="left">np.nanstd</td>
<td align="left">计算元素的标准差</td>
</tr>
<tr>
<td align="left">np.var</td>
<td align="left">np.nanvar</td>
<td align="left">计算元素的方差</td>
</tr>
<tr>
<td align="left">np.min</td>
<td align="left">np.nanmin</td>
<td align="left">找出最小值</td>
</tr>
<tr>
<td align="left">np.max</td>
<td align="left">np.nanmax</td>
<td align="left">找出最大值</td>
</tr>
<tr>
<td align="left">np.argmin</td>
<td align="left">np.nanargmin</td>
<td align="left">找出最小值的索引</td>
</tr>
<tr>
<td align="left">np.argmax</td>
<td align="left">np.nanargmax</td>
<td align="left">找出最大值的索引</td>
</tr>
<tr>
<td align="left">np.median</td>
<td align="left">np.nanmedian</td>
<td align="left">计算元素的中位数</td>
</tr>
<tr>
<td align="left">np.percentile</td>
<td align="left">np.nanpercentile</td>
<td align="left">计算基于元素排序的统计值</td>
</tr>
<tr>
<td align="left">np.any</td>
<td align="left">N/A</td>
<td align="left">验证任何一个元素是否为真</td>
</tr>
<tr>
<td align="left">np.all</td>
<td align="left">N/A</td>
<td align="left">验证所有元素是否为真</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">heights = np.random.random(<span class="number">25</span>) * <span class="number">175</span></span><br><span class="line">print(heights)</span><br><span class="line">print(<span class="string">"Mean height: "</span>, heights.mean())</span><br><span class="line">print(<span class="string">"Standard deviation:"</span>, heights.std())</span><br><span class="line">print(<span class="string">"Minimum height: "</span>, heights.min())</span><br><span class="line">print(<span class="string">"Maximum height: "</span>, heights.max())</span><br><span class="line">print(<span class="string">"25th percentile: "</span>, np.percentile(heights, <span class="number">25</span>))</span><br><span class="line">print(<span class="string">"Median: "</span>, np.median(heights))</span><br><span class="line">print(<span class="string">"75th percentile: "</span>, np.percentile(heights, <span class="number">75</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[165.22800319  87.82141828 109.19176656  20.23321914  55.52495932
  72.59458709 151.60410263  43.82968894  84.53099625 172.47296248
  90.90989587 107.25654201  21.11001655 144.60964009 105.53552247
  95.38690113  59.98367091  53.22113808  72.97888693 119.22763401
 153.20494731  89.32390906 117.12991202 102.5388967  109.35811287]
Mean height:  96.19229319557513
Standard deviation: 40.570450297029936
Minimum height:  20.233219138876752
Maximum height:  172.47296248187337
25th percentile:  72.59458709188556
Median:  95.38690113163136
75th percentile:  117.12991201839765</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn; seaborn.set()</span><br><span class="line"></span><br><span class="line">plt.hist(heights)</span><br><span class="line">plt.title(<span class="string">'Height Distribution of US Presidents'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'height (cm)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'number'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/26/python-numpy学习笔记/output_85_0.png" alt="png"></p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><ul>
<li>广播允许这些二进制操作用于不同大小的数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">a + <span class="number">5</span></span><br></pre></td></tr></table></figure>

<pre><code>array([6, 7, 8])</code></pre><ul>
<li>可以认为这个操作是将数值5扩展或重复至数组<code>[5, 5, 5]</code>，然后执行加法</li>
<li>下面这个例子，一维数组为扩展或广播了，它沿着第二个维度扩展，扩展到匹配M数组的形状</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">M + a</span><br></pre></td></tr></table></figure>

<pre><code>array([[2., 3., 4.],
       [2., 3., 4.],
       [2., 3., 4.]])</code></pre><ul>
<li>对两个数组同时广播，将 a 和b 都进行了扩展来匹配一个公共的形状，最终的结果是一个二维数组,例子如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">3</span>)</span><br><span class="line">b = np.arange(<span class="number">3</span>)[:, np.newaxis]</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>

<pre><code>[0 1 2]
[[0]
 [1]
 [2]]





array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])</code></pre><h4 id="广播的规则"><a href="#广播的规则" class="headerlink" title="广播的规则"></a>广播的规则</h4><ul>
<li>如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1</li>
<li>如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状</li>
<li>如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常</li>
</ul>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><ul>
<li>一个二维数组与一个一维数组相加：<blockquote>
<p>M = np.ones((2, 3))<br>a = np.arange(3)  </p>
</blockquote>
</li>
<li>形状如下<blockquote>
<p>M.shape = (2, 3)<br>a.shape = (3,)  </p>
</blockquote>
</li>
<li>可以看到，根据规则1，数组a的维度数更小，所以在其左边补1<blockquote>
<p>M.shape -&gt; (2, 3)<br>a.shape -&gt; (1, 3)  </p>
</blockquote>
</li>
<li>根据规则2，第一个维度不匹配，因此扩展这个维度以匹配数组<blockquote>
<p>M.shape -&gt; (2, 3)<br>a.shape -&gt; (2, 3)  </p>
</blockquote>
</li>
<li>现在两个数组的形状匹配了，可以看到它们的最终形状都为(2, 3)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">a = np.arange(<span class="number">3</span>)</span><br><span class="line">M + a</span><br></pre></td></tr></table></figure>

<pre><code>array([[1., 2., 3.],
       [1., 2., 3.]])</code></pre><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><ul>
<li>两个数组都需要广播：<blockquote>
<p>M = np.arange(3).reshape((3, 1))<br>a = np.arange(3)  </p>
</blockquote>
</li>
<li>形状如下<blockquote>
<p>M.shape = (3,1)<br>a.shape = (3,)  </p>
</blockquote>
</li>
<li>可以看到，根据规则1，数组a的维度数更小，所以在其左边补1<blockquote>
<p>M.shape -&gt; (3, 1)<br>a.shape -&gt; (1, 3)  </p>
</blockquote>
</li>
<li>根据规则2，需要更新这两个数组的维度来相互匹配<blockquote>
<p>M.shape -&gt; (3, 3)<br>a.shape -&gt; (3, 3)  </p>
</blockquote>
</li>
<li>现在两个数组的形状匹配了，可以看到它们的最终形状都为(3, 3)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M = np.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))  </span><br><span class="line">a = np.arange(<span class="number">3</span>) </span><br><span class="line">M + a</span><br></pre></td></tr></table></figure>

<pre><code>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])</code></pre><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h5><ul>
<li>两个数组不兼容：<blockquote>
<p>M = np.ones((3, 2))<br>a = np.arange(3)  </p>
</blockquote>
</li>
<li>形状如下<blockquote>
<p>M.shape = (3, 2)<br>a.shape = (3,)  </p>
</blockquote>
</li>
<li>可以看到，根据规则1，数组a的维度数更小，所以在其左边补1<blockquote>
<p>M.shape -&gt; (3, 2)<br>a.shape -&gt; (1, 3)  </p>
</blockquote>
</li>
<li>根据规则2，第一个维度不匹配，因此扩展这个维度以匹配数组<blockquote>
<p>M.shape -&gt; (3, 2)<br>a.shape -&gt; (3, 3)  </p>
</blockquote>
</li>
<li>现在需要用到规则 3——最终的形状还是不匹配，因此这两个数组是不兼容的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M = np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">a = np.arange(<span class="number">3</span>) </span><br><span class="line">M + a</span><br></pre></td></tr></table></figure>

<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-64-932af115d5e2&gt; in &lt;module&gt;
      1 M = np.ones((3,2))
      2 a = np.arange(3)
----&gt; 3 M + a


ValueError: operands could not be broadcast together with shapes (3,2) (3,) </code></pre><h4 id="广播的应用"><a href="#广播的应用" class="headerlink" title="广播的应用"></a>广播的应用</h4><h5 id="数据的归一化"><a href="#数据的归一化" class="headerlink" title="数据的归一化"></a>数据的归一化</h5><ul>
<li>假设有一个有10个观察值的数组，每个观察值包含3个数值<blockquote>
<p>X = np.random.random((10, 3))  </p>
</blockquote>
</li>
<li>计算每个特征的均值<blockquote>
<p>Xmean = X.mean(0)  </p>
</blockquote>
</li>
<li>归一化操作<blockquote>
<p>X_centered = X - Xmean  </p>
</blockquote>
</li>
</ul>
<h5 id="画一个二维数组"><a href="#画一个二维数组" class="headerlink" title="画一个二维数组"></a>画一个二维数组</h5><ul>
<li>广播另外一个非常有用的地方在于，它能基于二维函数显示图像。我们希望定义一个函数 z = f (x, y)，可以用广播沿着数值区间计算该函数<blockquote>
<p>x = np.linspace(0, 5, 50)<br>y = np.linspace(0, 5, 50)[:, np.newaxis]<br>z = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)  </span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">50</span>)[:, np.newaxis]  </span><br><span class="line">z = np.sin(x) ** <span class="number">10</span> + np.cos(<span class="number">10</span> + y * x) * np.cos(x)</span><br><span class="line"></span><br><span class="line">plt.imshow(z, origin=<span class="string">'lower'</span>, extent=[<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>], cmap=<span class="string">'viridis'</span>)</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;matplotlib.colorbar.Colorbar at 0x1409baa39b0&gt;</code></pre><p><img src="/2019/07/26/python-numpy学习笔记/output_99_1.png" alt="png"></p>
<h3 id="比较、掩码和布尔逻辑"><a href="#比较、掩码和布尔逻辑" class="headerlink" title="比较、掩码和布尔逻辑"></a>比较、掩码和布尔逻辑</h3><h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><ul>
<li>数组的逐元素操作,结果是一个布尔数据类型的数组  </li>
</ul>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">对应通用函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">==</td>
<td align="left">np.equal</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">np.not_equal</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">np.less</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">np.less_equal</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">np.greater</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">np.greater_equal</td>
<td align="left">大于等于</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐元素比较</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(x &lt; <span class="number">3</span>)</span><br><span class="line">print(x &gt; <span class="number">3</span>)</span><br><span class="line">print(x &lt;= <span class="number">3</span>)</span><br><span class="line">print(x &gt;= <span class="number">3</span>)</span><br><span class="line">print(x != <span class="number">3</span>)</span><br><span class="line">print(x == <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 符合表达式实现两个数组的逐元素比较</span></span><br><span class="line">print((<span class="number">2</span> * x) == (x ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[ True  True False False False]
[False False False  True  True]
[ True  True  True False False]
[False False  True  True  True]
[ True  True False  True  True]
[False False  True False False]
[False  True False False False]</code></pre><h4 id="操作布尔数组"><a href="#操作布尔数组" class="headerlink" title="操作布尔数组"></a>操作布尔数组</h4><ul>
<li><p>统计记录的个数</p>
<blockquote>
<p>np.count_nonzero(x &lt; 6)<br>np.sum(x &lt; 6) # False会被解释成0，True会被解释成1</p>
<ul>
<li>sum的好处是，可以沿着行或列进行</li>
<li>快速检车任意或所有的这些值是否为True<br>np.any(x &gt; 8)<br>np.all(x &lt; 0)  </li>
</ul>
</blockquote>
<ul>
<li>上述两个函数也可以通过指定<code>axis</code>来指定行列</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">x = rng.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(np.count_nonzero(x &lt; <span class="number">6</span>))</span><br><span class="line">print(np.sum(x &lt; <span class="number">6</span>))</span><br><span class="line">print(np.any(x &gt; <span class="number">7</span>))</span><br><span class="line">print(np.all(x &lt; <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<pre><code>8
8
True
True</code></pre><ul>
<li>布尔运算符<blockquote>
<p>统计(0.5, 1)之间的数量和<br>np.sum((array &gt; 0.5) &amp; (inches &lt; 1))<br>np.sum(~( (array &lt;= 0.5) | (array &gt;= 1) ))  </p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">通用函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">np.bitwise_and</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">np.bitwise_xor</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">np.bitwise_not</td>
</tr>
</tbody></table>
<h4 id="将布尔数组作为掩码"><a href="#将布尔数组作为掩码" class="headerlink" title="将布尔数组作为掩码"></a>将布尔数组作为掩码</h4><ul>
<li>为了将特定值从数组中选出，可以进行简单的索引，即掩码操作<blockquote>
<p>x[x &lt; 5]  </p>
</blockquote>
</li>
<li>返回的是一个一维数组，它包含了所有满足条件的值。换句话说，所有的这些值是掩码数组对应位置为 True 的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line">inches = np.random.random(<span class="number">365</span>)*<span class="number">10</span></span><br><span class="line">rainy = (inches &gt; <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 构建一个包含整个夏季日期的掩码（6月21日是第172天）</span></span><br><span class="line">summer = (np.arange(<span class="number">365</span>) - <span class="number">172</span> &lt; <span class="number">90</span>) &amp; (np.arange(<span class="number">365</span>) - <span class="number">172</span> &gt; <span class="number">0</span>)</span><br><span class="line">print(<span class="string">"Median precip on rainy days in 2014 (inches): "</span>,</span><br><span class="line">np.median(inches[rainy]))</span><br><span class="line">print(<span class="string">"Median precip on summer days in 2014 (inches): "</span>,</span><br><span class="line">np.median(inches[summer]))</span><br><span class="line">print(<span class="string">"Maximum precip on summer days in 2014 (inches): "</span>,</span><br><span class="line">np.max(inches[summer]))</span><br><span class="line">print(<span class="string">"Median precip on non-summer rainy days (inches):"</span>,</span><br><span class="line">np.median(inches[rainy &amp; ~summer]))</span><br></pre></td></tr></table></figure>

<pre><code>Median precip on rainy days in 2014 (inches):  6.3526921480470175
Median precip on summer days in 2014 (inches):  4.619087615684484
Maximum precip on summer days in 2014 (inches):  9.930332610947918
Median precip on non-summer rainy days (inches): 6.533648713530407</code></pre><ul>
<li><p>and 和 or 判断整个对象是真或假，而 &amp; 和 | 是指每个对象中的比特位  </p>
<ul>
<li>使用 and 或 or 时，就等于让 Python 将这个对象当作整个布尔实体，所有非零的整数都会被当作是 True<blockquote>
<p>bool(-1), bool(0)<br>(True, False)<br>bool(-1 and 0)<br>Flase<br>bool(-1 or 0)<br>True  </p>
</blockquote>
</li>
<li>对整数使用 &amp; 和 | 时，表达式操作的是元素的比特，将 and 或 or 应用于组成该数字的每个比特<blockquote>
<p>bin(42)<br>‘0b101010’<br>bin(59)<br>‘0b111011’<br>bin(42 &amp; 59)<br>‘0b101010’<br>bin(42 | 59)<br>‘0b111011’  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>NumPy 中有一个布尔数组时，该数组可以被当作是由比特字符组成的，其中 1 = True、0 = False。这样的数组可以用上面介绍的方式进行 &amp; 和 | 的操作：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=bool)</span><br><span class="line">B = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=bool)</span><br><span class="line">A | B</span><br></pre></td></tr></table></figure>

<pre><code>array([ True,  True,  True, False,  True,  True])</code></pre><ul>
<li>而用 or 来计算这两个数组时，Python 会计算整个数组对象的真或假，这会导致程序出错</li>
<li>同样，对给定数组进行逻辑运算时，你也应该使用 | 或 &amp;，而不是 or 或 and</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">(x &gt; <span class="number">4</span>) &amp; (x &lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([False, False, False, False, False,  True,  True,  True, False,
       False])</code></pre><h3 id="花哨的索引"><a href="#花哨的索引" class="headerlink" title="花哨的索引"></a>花哨的索引</h3><h4 id="探索花哨的索引"><a href="#探索花哨的索引" class="headerlink" title="探索花哨的索引"></a>探索花哨的索引</h4><ul>
<li>概念，传递一个索引数组来一次性获得多个数组元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand = np.random.RandomState(<span class="number">30</span>)</span><br><span class="line">x = rand.randint(<span class="number">100</span>, size = <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 传递索引的列表或数组来获取结果</span></span><br><span class="line">ind = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">x[ind]</span><br></pre></td></tr></table></figure>

<pre><code>array([45, 53, 12])</code></pre><ul>
<li>结果的形状与索引数组的形状一致，而不是与被索引的数组形状一致</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind = np.array([[<span class="number">3</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">x[ind]</span><br></pre></td></tr></table></figure>

<pre><code>array([[45, 53],
       [12, 23]])</code></pre><ul>
<li>对于多个维度的索引，和标准索引一样，第一个索引指的是行，第二个索引指的是列</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">X[row, col]</span><br></pre></td></tr></table></figure>

<pre><code>array([ 2,  5, 11])</code></pre><ul>
<li>索引值的配对遵循广播的规则</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[row[:, np.newaxis], col]</span><br></pre></td></tr></table></figure>

<pre><code>array([[ 2,  1,  3],
       [ 6,  5,  7],
       [10,  9, 11]])</code></pre><h4 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h4><ul>
<li>花哨索引与其他索引方案结合使用<blockquote>
<p>花哨索引和简单的索引组合使用</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">2</span>, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<pre><code>array([10,  8,  9])</code></pre><blockquote>
<p>花哨索引和切片组合</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1</span>:, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<pre><code>array([[ 6,  4,  5],
       [10,  8,  9]])</code></pre><blockquote>
<p>花哨索引和掩码组合使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=bool)</span><br><span class="line">X[row[:, np.newaxis], mask]</span><br></pre></td></tr></table></figure>

<pre><code>array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])</code></pre><h4 id="示例：选择随机点"><a href="#示例：选择随机点" class="headerlink" title="示例：选择随机点"></a>示例：选择随机点</h4><ul>
<li>有一个 N×D 的矩阵，表示在 D 个维度的 N 个点</li>
<li>利用花哨的索引随机选取 20 个点——选择 20 个随机的、不重复的索引值，并利用这些索引值选取到原始数组对应的值</li>
<li>通常用于快速分割数据，即需要分割训练 / 测试数据集以验证统计模型时，以及在解答统计问题时的抽样方法中使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建数组</span></span><br><span class="line">mean = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">      [<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line">X = rand.multivariate_normal(mean, cov, <span class="number">100</span>)</span><br><span class="line">X.shape</span><br></pre></td></tr></table></figure>

<pre><code>(100, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘画</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/26/python-numpy学习笔记/output_126_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取随机点</span></span><br><span class="line">indices = np.random.choice(X.shape[<span class="number">0</span>], <span class="number">20</span>, replace=<span class="literal">False</span>)</span><br><span class="line">selection = X[indices]</span><br><span class="line">selection.shape</span><br></pre></td></tr></table></figure>

<pre><code>(20, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.scatter(selection[:, <span class="number">0</span>], selection[:, <span class="number">1</span>],</span><br><span class="line">            facecolor=<span class="string">'none'</span>, edgecolor=<span class="string">'b'</span>, s=<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/26/python-numpy学习笔记/output_128_0.png" alt="png"></p>
<h4 id="用花哨索引修改值"><a href="#用花哨索引修改值" class="headerlink" title="用花哨索引修改值"></a>用花哨索引修改值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">i = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>])</span><br><span class="line">x[i] = <span class="number">99</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[ 0 99 99  3 99  5  6  7 99  9]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[i] -= <span class="number">10</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[ 0 89 89  3 89  5  6  7 89  9]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会累加</span></span><br><span class="line">x = np.zeros(<span class="number">10</span>)</span><br><span class="line">i = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">x[i] += <span class="number">1</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<pre><code>array([0., 0., 1., 1., 1., 0., 0., 0., 0., 0.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累加</span></span><br><span class="line">x = np.zeros(<span class="number">10</span>)</span><br><span class="line">np.add.at(x, i, <span class="number">1</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<pre><code>array([0., 0., 1., 2., 3., 0., 0., 0., 0., 0.])</code></pre><h4 id="示例：数据区间划分"><a href="#示例：数据区间划分" class="headerlink" title="示例：数据区间划分"></a>示例：数据区间划分</h4><ul>
<li>创建一个数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">x = np.random.randn(<span class="number">100</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[ 0.49671415 -0.1382643   0.64768854  1.52302986 -0.23415337 -0.23413696
  1.57921282  0.76743473 -0.46947439  0.54256004 -0.46341769 -0.46572975
  0.24196227 -1.91328024 -1.72491783 -0.56228753 -1.01283112  0.31424733
 -0.90802408 -1.4123037   1.46564877 -0.2257763   0.0675282  -1.42474819
 -0.54438272  0.11092259 -1.15099358  0.37569802 -0.60063869 -0.29169375
 -0.60170661  1.85227818 -0.01349722 -1.05771093  0.82254491 -1.22084365
  0.2088636  -1.95967012 -1.32818605  0.19686124  0.73846658  0.17136828
 -0.11564828 -0.3011037  -1.47852199 -0.71984421 -0.46063877  1.05712223
  0.34361829 -1.76304016  0.32408397 -0.38508228 -0.676922    0.61167629
  1.03099952  0.93128012 -0.83921752 -0.30921238  0.33126343  0.97554513
 -0.47917424 -0.18565898 -1.10633497 -1.19620662  0.81252582  1.35624003
 -0.07201012  1.0035329   0.36163603 -0.64511975  0.36139561  1.53803657
 -0.03582604  1.56464366 -2.6197451   0.8219025   0.08704707 -0.29900735
  0.09176078 -1.98756891 -0.21967189  0.35711257  1.47789404 -0.51827022
 -0.8084936  -0.50175704  0.91540212  0.32875111 -0.5297602   0.51326743
  0.09707755  0.96864499 -0.70205309 -0.32766215 -0.39210815 -1.46351495
  0.29612028  0.26105527  0.00511346 -0.23458713]</code></pre><ul>
<li>手动计算直方图</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bins = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">counts = np.zeros_like(bins)</span><br><span class="line">print(bins)</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure>

<pre><code>[-5.         -4.47368421 -3.94736842 -3.42105263 -2.89473684 -2.36842105
 -1.84210526 -1.31578947 -0.78947368 -0.26315789  0.26315789  0.78947368
  1.31578947  1.84210526  2.36842105  2.89473684  3.42105263  3.94736842
  4.47368421  5.        ]
[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</code></pre><ul>
<li>为每个x找到合适的区间</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = np.searchsorted(bins, x)</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>

<pre><code>[11 10 11 13 10 10 13 11  9 11  9  9 10  6  7  9  8 11  8  7 13 10 10  7
  9 10  8 11  9  9  9 14 10  8 12  8 10  6  7 10 11 10 10  9  7  9  9 12
 11  7 11  9  9 11 12 12  8  9 11 12  9 10  8  8 12 13 10 12 11  9 11 13
 10 13  5 12 10  9 10  6 10 11 13  9  8  9 12 11  9 11 10 12  9  9  9  7
 11 10 10 10]</code></pre><ul>
<li>为每个区间加上1</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.add.at(counts, i, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>计数数组 counts 反映的是在每个区间中的点的个数，即直方图分布</li>
<li>画出结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(bins, counts, linestyle=<span class="string">'steps'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>[&lt;matplotlib.lines.Line2D at 0x1409bbe1710&gt;]</code></pre><p><img src="/2019/07/26/python-numpy学习笔记/output_143_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上述结果的另一种实现方法</span></span><br><span class="line">plt.hist(x, bins, histtype=<span class="string">'step'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/26/python-numpy学习笔记/output_144_0.png" alt="png"></p>
<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>np.sort<blockquote>
<p>不修改原始输入数组的基础上返回一个排好序的数组  </p>
</blockquote>
</li>
<li>sort方法<blockquote>
<p>用排序号的数组替代原始数组  </p>
</blockquote>
</li>
<li>np.argsort<blockquote>
<p>返回原始数据排好序的索引值</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line">np.sort(x)</span><br></pre></td></tr></table></figure>

<pre><code>array([1, 2, 3, 5, 7, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.sort()</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<pre><code>[1 2 3 5 7 8]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line">np.argsort(x)</span><br></pre></td></tr></table></figure>

<pre><code>array([5, 2, 0, 1, 3, 4], dtype=int64)</code></pre><ul>
<li>按行或列排序，使用axis参数<blockquote>
<p>axis=0，按列排序<br>axis=1，按行排序</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">X = rand.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">4</span>, <span class="number">6</span>))</span><br><span class="line">print(X)</span><br><span class="line">print(np.sort(X, axis=<span class="number">0</span>))</span><br><span class="line">print(np.sort(X, axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[[6 3 7 4 6 9]
 [2 6 7 4 3 7]
 [7 2 5 4 1 7]
 [5 1 4 0 9 5]]
[[2 1 4 0 1 5]
 [5 2 5 4 3 7]
 [6 3 7 4 6 7]
 [7 6 7 4 9 9]]
[[3 4 6 6 7 9]
 [2 3 4 6 7 7]
 [1 2 4 5 7 7]
 [0 1 4 5 5 9]]</code></pre><h4 id="部分排序：分隔"><a href="#部分排序：分隔" class="headerlink" title="部分排序：分隔"></a>部分排序：分隔</h4><ul>
<li>np.partition<blockquote>
<p>输入数组和数字K<br>输出是一个新数组，左边是第K小的值，右边是任意排序的其他值。两个分隔的区域中，元素都是任意排序  </p>
</blockquote>
</li>
<li>np.argpartition<blockquote>
<p>计算分隔的索引值</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">np.partition(x, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([3, 1, 2, 4, 7, 5, 8, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿着多维数组的任意轴分隔</span></span><br><span class="line">np.partition(X, <span class="number">2</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<pre><code>array([[3, 4, 6, 7, 6, 9],
       [2, 3, 4, 7, 6, 7],
       [1, 2, 4, 5, 7, 7],
       [0, 1, 4, 5, 9, 5]])</code></pre><h4 id="示例：K个最近邻"><a href="#示例：K个最近邻" class="headerlink" title="示例：K个最近邻"></a>示例：K个最近邻</h4><ul>
<li>利用 argsort 函数沿着多个轴快速找到集合中每个点的最近邻</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在二维平面上创建一个有10个随机点的集合</span></span><br><span class="line">X = rand.rand(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], s=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<pre><code>&lt;matplotlib.collections.PathCollection at 0x1409bc845c0&gt;</code></pre><p><img src="/2019/07/26/python-numpy学习笔记/output_155_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两两数据点对间的距离</span></span><br><span class="line">dist_sq = np.sum((X[:,np.newaxis,:] - X[np.newaxis,:,:]) ** <span class="number">2</span>, axis=<span class="number">-1</span>)</span><br><span class="line">nearest = np.argsort(dist_sq, axis=<span class="number">1</span>)</span><br><span class="line">K = <span class="number">2</span></span><br><span class="line">nearest_partition = np.argpartition(dist_sq, K + <span class="number">1</span>, axis=<span class="number">1</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], s=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 将每个点与它的两个最近邻连接</span></span><br><span class="line">K = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> nearest_partition[i, :K+<span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># 画一条从X[i]到X[j]的线段</span></span><br><span class="line">        <span class="comment"># 用zip方法实现：</span></span><br><span class="line">        plt.plot(*zip(X[j], X[i]), color=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/26/python-numpy学习笔记/output_156_0.png" alt="png"></p>
<h3 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h3><ul>
<li>指定复合数据类型，构造一个结构化数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.zeros(<span class="number">4</span>, dtype=int)</span><br><span class="line"><span class="comment"># 使用复合数据结构的结构化数组</span></span><br><span class="line">data = np.zeros(<span class="number">4</span>, dtype=&#123;<span class="string">'names'</span>:(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'weight'</span>),</span><br><span class="line">                         <span class="string">'formats'</span>:(<span class="string">'U10'</span>, <span class="string">'i4'</span>, <span class="string">'f8'</span>)&#125;)</span><br><span class="line"><span class="comment"># U10表示‘长度不超过10的Unicode字符串’</span></span><br><span class="line"><span class="comment"># i4表示‘4字节（32比特）整型’</span></span><br><span class="line"><span class="comment"># f8表示‘8字节（64比特位）浮点型’</span></span><br><span class="line">print(data.dtype)</span><br></pre></td></tr></table></figure>

<pre><code>[(&apos;name&apos;, &apos;&lt;U10&apos;), (&apos;age&apos;, &apos;&lt;i4&apos;), (&apos;weight&apos;, &apos;&lt;f8&apos;)]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Cathy'</span>, <span class="string">'Doug'</span>]</span><br><span class="line">age = [<span class="number">25</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">19</span>]</span><br><span class="line">weight = [<span class="number">55.0</span>, <span class="number">85.5</span>, <span class="number">68.0</span>, <span class="number">61.5</span>]</span><br><span class="line">data[<span class="string">'name'</span>] = name</span><br><span class="line">data[<span class="string">'age'</span>] = age</span><br><span class="line">data[<span class="string">'weight'</span>] = weight</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

<pre><code>[(&apos;Alice&apos;, 25, 55. ) (&apos;Bob&apos;, 45, 85.5) (&apos;Cathy&apos;, 37, 68. )
 (&apos;Doug&apos;, 19, 61.5)]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有名字</span></span><br><span class="line">data[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<pre><code>array([&apos;Alice&apos;, &apos;Bob&apos;, &apos;Cathy&apos;, &apos;Doug&apos;], dtype=&apos;&lt;U10&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据第一行</span></span><br><span class="line">data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<pre><code>(&apos;Alice&apos;, 25, 55.)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最后一行的名字</span></span><br><span class="line">data[<span class="number">-1</span>][<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<pre><code>&apos;Doug&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取年龄小于30岁的人的名字</span></span><br><span class="line">data[data[<span class="string">'age'</span>] &lt; <span class="number">30</span>][<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<pre><code>array([&apos;Alice&apos;, &apos;Doug&apos;], dtype=&apos;&lt;U10&apos;)</code></pre><h4 id="生成结构化数组"><a href="#生成结构化数组" class="headerlink" title="生成结构化数组"></a>生成结构化数组</h4><ul>
<li>字典的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.dtype(&#123;<span class="string">'names'</span>:(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'weight'</span>),</span><br><span class="line">         <span class="string">'formats'</span>:(<span class="string">'U10'</span>, <span class="string">'i4'</span>, <span class="string">'f8'</span>)&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>dtype([(&apos;name&apos;, &apos;&lt;U10&apos;), (&apos;age&apos;, &apos;&lt;i4&apos;), (&apos;weight&apos;, &apos;&lt;f8&apos;)])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数值数据类型可以用 Python 类型或 NumPy 的 dtype 类型指定</span></span><br><span class="line">np.dtype(&#123;<span class="string">'names'</span>:(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'weight'</span>),</span><br><span class="line"><span class="string">'formats'</span>:((np.str_, <span class="number">10</span>), int, np.float32)&#125;)</span><br></pre></td></tr></table></figure>

<pre><code>dtype([(&apos;name&apos;, &apos;&lt;U10&apos;), (&apos;age&apos;, &apos;&lt;i4&apos;), (&apos;weight&apos;, &apos;&lt;f4&apos;)])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组列表</span></span><br><span class="line">np.dtype([(<span class="string">'name'</span>, <span class="string">'S10'</span>), (<span class="string">'age'</span>, <span class="string">'i4'</span>), (<span class="string">'weight'</span>, <span class="string">'f8'</span>)])</span><br></pre></td></tr></table></figure>

<pre><code>dtype([(&apos;name&apos;, &apos;S10&apos;), (&apos;age&apos;, &apos;&lt;i4&apos;), (&apos;weight&apos;, &apos;&lt;f8&apos;)])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不指定类型的名称</span></span><br><span class="line">np.dtype(<span class="string">'S10,i4,f8'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>dtype([(&apos;f0&apos;, &apos;S10&apos;), (&apos;f1&apos;, &apos;&lt;i4&apos;), (&apos;f2&apos;, &apos;&lt;f8&apos;)])</code></pre><ul>
<li><p>简写的字符串格式</p>
<blockquote>
<p>第一个（可选）字符是 &lt; 或者 &gt;，分别表示“低字节序”（little endian）和“高字节序”（bid endian），表示字节（bytes）类型的数据在内存中存放顺序的习惯用法<br>后一个字符指定的是数据的类型：字符、字节、整型、浮点型，等等<br>最后一个字符表示该对象的字节大小  </p>
</blockquote>
</li>
<li><p>NumPy数据类型</p>
<table>
<thead>
<tr>
<th align="left">NumPy数据类型符号</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘b’</td>
<td align="left">字节型</td>
<td align="left">np.dtype(‘b’)</td>
</tr>
<tr>
<td align="left">‘i’</td>
<td align="left">有符号整型</td>
<td align="left">np.dtype(‘i4’) == np.int32</td>
</tr>
<tr>
<td align="left">‘u’</td>
<td align="left">无符号整型</td>
<td align="left">np.dtype(‘u1’) == np.uint8</td>
</tr>
<tr>
<td align="left">‘f’</td>
<td align="left">浮点型</td>
<td align="left">np.dtype(‘f8’) == np.int64</td>
</tr>
<tr>
<td align="left">‘c’</td>
<td align="left">复数浮点型</td>
<td align="left">np.dtype(‘c16’) == np.complex128</td>
</tr>
<tr>
<td align="left">‘S’、’a’</td>
<td align="left">字符串</td>
<td align="left">np.dtype(‘S5’)</td>
</tr>
<tr>
<td align="left">‘U’</td>
<td align="left">Unicode 编码字符串</td>
<td align="left">np.dtype(‘U’) == np.str_</td>
</tr>
<tr>
<td align="left">‘V’</td>
<td align="left">原生数据，raw data（空，void）</td>
<td align="left">np.dtype(‘V’) == np.void</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="跟高级的复合类型"><a href="#跟高级的复合类型" class="headerlink" title="跟高级的复合类型"></a>跟高级的复合类型</h4><ul>
<li>创建一种类型，其中每个元素都包含一个数组或矩阵</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tp = np.dtype([(<span class="string">'id'</span>, <span class="string">'i8'</span>), (<span class="string">'mat'</span>, <span class="string">'f8'</span>, (<span class="number">3</span>, <span class="number">3</span>))])</span><br><span class="line">X = np.zeros(<span class="number">1</span>, dtype=tp)</span><br><span class="line">print(X[<span class="number">0</span>])</span><br><span class="line">print(X[<span class="string">'mat'</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<pre><code>(0, [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]</code></pre><h4 id="记录数组：结构化数组的扭转"><a href="#记录数组：结构化数组的扭转" class="headerlink" title="记录数组：结构化数组的扭转"></a>记录数组：结构化数组的扭转</h4><ul>
<li>np.recarray<blockquote>
<p>域可以像属性一样获取，而不是像字典的键那样获取  </p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消耗内存更多</span></span><br><span class="line">data_rec = data.view(np.recarray)</span><br><span class="line">data_rec.age</span><br></pre></td></tr></table></figure>

<pre><code>array([25, 45, 37, 19])</code></pre><h3 id="附：还有一些其他的"><a href="#附：还有一些其他的" class="headerlink" title="附：还有一些其他的"></a>附：还有一些其他的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nd10 = np.random.random([<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line">np.savetxt(X=nd10,fname=<span class="string">'test1.txt'</span>)</span><br><span class="line">nd11 = np.loadtxt(<span class="string">'test1.txt'</span>)</span><br><span class="line">print(nd10,nd11)</span><br></pre></td></tr></table></figure>

<pre><code>[[0.417411   0.22210781 0.11986537 0.33761517 0.9429097  0.32320293
  0.51879062]
 [0.70301896 0.3636296  0.97178208 0.96244729 0.2517823  0.49724851
  0.30087831]
 [0.28484049 0.03688695 0.60956433 0.50267902 0.05147875 0.27864646
  0.90826589]
 [0.23956189 0.14489487 0.48945276 0.98565045 0.24205527 0.67213555
  0.76161962]
 [0.23763754 0.72821635 0.36778313 0.63230583 0.63352971 0.53577468
  0.09028977]] [[0.417411   0.22210781 0.11986537 0.33761517 0.9429097  0.32320293
  0.51879062]
 [0.70301896 0.3636296  0.97178208 0.96244729 0.2517823  0.49724851
  0.30087831]
 [0.28484049 0.03688695 0.60956433 0.50267902 0.05147875 0.27864646
  0.90826589]
 [0.23956189 0.14489487 0.48945276 0.98565045 0.24205527 0.67213555
  0.76161962]
 [0.23763754 0.72821635 0.36778313 0.63230583 0.63352971 0.53577468
  0.09028977]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#截取数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">2019</span>)</span><br><span class="line">nd12 = np.random.random([<span class="number">10</span>])</span><br><span class="line">print(nd12)</span><br><span class="line">print(nd12[<span class="number">3</span>])</span><br><span class="line">print(nd12[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">print(nd12[<span class="number">2</span>:<span class="number">9</span>:<span class="number">2</span>])</span><br><span class="line">print(nd12[::<span class="number">-3</span>])</span><br><span class="line">nd13 = np.arange(<span class="number">25</span>).reshape([<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line">print(nd13)</span><br><span class="line">print(nd13[<span class="number">1</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">print(nd13[(nd13&gt;<span class="number">4</span>)&amp;(nd13&lt;<span class="number">9</span>)])</span><br><span class="line">print(nd13[[<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line">print(nd13[:,<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<pre><code>[0.90348221 0.39308051 0.62396996 0.6378774  0.88049907 0.29917202
 0.70219827 0.90320616 0.88138193 0.4057498 ]
0.6378774010222266
[0.39308051 0.62396996 0.6378774 ]
[0.62396996 0.88049907 0.70219827 0.88138193]
[0.4057498  0.70219827 0.6378774  0.90348221]
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
[[6 7 8]]
[5 6 7 8]
[[ 5  6  7  8  9]
 [15 16 17 18 19]]
[[ 1  2]
 [ 6  7]
 [11 12]
 [16 17]
 [21 22]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#random.choice随机抽取</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random <span class="keyword">as</span> nr</span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">25</span>,dtype=float)</span><br><span class="line">c1 = nr.choice(a,size=(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">c2 = nr.choice(a,size=(<span class="number">3</span>,<span class="number">4</span>),replace=<span class="literal">False</span>) <span class="comment">#replace缺省为True，即可重复抽取</span></span><br><span class="line">c3 = nr.choice(a,size=(<span class="number">3</span>,<span class="number">4</span>),p = a/np.sum(a))</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br><span class="line">print(c3)</span><br></pre></td></tr></table></figure>

<pre><code>[[19.  6. 24. 22.]
 [21. 17. 16.  2.]
 [23. 15. 13. 11.]]
[[ 5. 14. 23. 15.]
 [ 8. 24.  6. 18.]
 [13. 10. 21. 11.]]
[[19. 21. 18. 11.]
 [10. 21. 23. 19.]
 [18. 19. 11. 20.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#矩阵操作</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nd15 = np.arange(<span class="number">9</span>).reshape([<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#转置</span></span><br><span class="line">print(np.transpose(nd15))</span><br><span class="line"></span><br><span class="line"><span class="comment">#乘法</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = np.arange(<span class="number">8</span>).reshape([<span class="number">4</span>,<span class="number">2</span>])</span><br><span class="line">print(a.dot(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵的迹</span></span><br><span class="line">print(a.trace())</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算行列式</span></span><br><span class="line">print(np.linalg.det(nd15))</span><br><span class="line"></span><br><span class="line"><span class="comment">#逆矩阵</span></span><br><span class="line">c = np.random.random([<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">print(np.linalg.solve(c,np.eye(<span class="number">3</span>)))</span><br></pre></td></tr></table></figure>

<pre><code>[[0 3 6]
 [1 4 7]
 [2 5 8]]
[[ 28  34]
 [ 76  98]
 [124 162]]
15
0.0
[[ 0.79111977  4.79625456 -2.59458683]
 [ 0.72853989 -3.64821752  1.90992826]
 [-2.01814852 -5.08596471  4.61137684]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据的合并与展平</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">c = np.array([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">print(np.append(a,b))</span><br><span class="line">print(np.concatenate([a,b]))</span><br></pre></td></tr></table></figure>

<pre><code>[1 2 3 4 5 6]
[1 2 3 4 5 6]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多维数组的合并</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#按行合并</span></span><br><span class="line">print(np.append(a,b,axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment">#按列合并</span></span><br><span class="line">print(np.append(a,b,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[[0 1]
 [2 3]
 [0 1]
 [2 3]]
[[0 1 0 1]
 [2 3 2 3]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#展平</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nd16 = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">-1</span>)</span><br><span class="line">print(nd16)</span><br><span class="line"><span class="comment">#按列展平</span></span><br><span class="line">print(nd16.ravel(<span class="string">'F'</span>))</span><br><span class="line"><span class="comment">#按行展平</span></span><br><span class="line">print(nd16.ravel())</span><br></pre></td></tr></table></figure>

<pre><code>[[0 1 2]
 [3 4 5]]
[0 3 1 4 2 5]
[0 1 2 3 4 5]</code></pre>
          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/07/21/批量可视化fastp输出结果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/21/批量可视化fastp输出结果/" class="post-title-link" itemprop="url">批量可视化fastp输出结果</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-21 18:34:33 / 修改时间：19:51:18" itemprop="dateCreated datePublished" datetime="2019-07-21T18:34:33+08:00">2019-07-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS之小脚本/" itemprop="url" rel="index"><span itemprop="name">我的WGS之小脚本</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>fastp是一个非常方便的基因组数据处理软件，之前在质控的环节就有用到它。</li>
<li>这个软件比较方便的地方就是对于处理前后的数据情况会输出一个可视化的网页报告，可以直接查看，报告内容也十分的简单易懂。</li>
<li>对于单个数据或者少数数据直接这么查看是比较方便的，但是对于大批量的数据进行处理以后，要还是一个一个报告查看，就让人很抓狂了。</li>
<li>最近就碰到了这么一个问题，于是写了一个python小脚本，进行批量结果的可视化，做一下笔记，怕以后忘了。</li>
</ul>
<hr>
<ul>
<li>要进行批量可视化的前提是可视化的数据，fastp在处理完数据后，除了一个网页格式报告之外，还有一个json格式的报告，这就是我们的数据来源。</li>
<li>本脚本使用python3.x的版本，设计第三方库如下：<ul>
<li>pandas</li>
<li>matplotlib</li>
</ul>
</li>
</ul>
<ul>
<li><p>首先为这个脚本新建一个目录，并在目录下新建一个report目录（目录名随意）和一个python脚本（脚本名随意），report目录用来放fastp的json格式报告，如图，我的目录下面就放了两百多份报告。</p>
<p><img src="/2019/07/21/批量可视化fastp输出结果/%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
</li>
</ul>
<ul>
<li>这个实现本身很简单，主要要考虑的一点是WGS数据很多时候不是一个sample一对fastq文件，很多时候一个sample对应好多对fastq文件，那么fastp也会输出多个报告，对于这些报告我们要进行合并。</li>
<li>下面就来解析一下脚本</li>
</ul>
<p>先上完整脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json, os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">result_list = os.listdir(<span class="string">'./report'</span>)</span><br><span class="line">result_dict = &#123;&#125;</span><br><span class="line">merge_result_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result_list:</span><br><span class="line">    <span class="keyword">if</span> i.endswith(<span class="string">'.json'</span>):</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'./report/'</span> + i, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            result_dict[i] = json.load(f)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> result_dict.items():</span><br><span class="line">	key = k.split(<span class="string">'_'</span>)[<span class="number">0</span>]</span><br><span class="line">	merge_result_dict[key] = &#123;<span class="string">'total_bases'</span>: v[<span class="string">'summary'</span>][<span class="string">'before_filtering'</span>][<span class="string">'total_bases'</span>] + merge_result_dict.get(key, &#123;<span class="string">'total_bases'</span>: <span class="number">0</span>&#125;).get(<span class="string">'total_bases'</span>, <span class="number">0</span>),</span><br><span class="line">	<span class="string">'q20_bases'</span>: v[<span class="string">'summary'</span>][<span class="string">'before_filtering'</span>][<span class="string">'q20_bases'</span>] + merge_result_dict.get(key, &#123;<span class="string">'q20_bases'</span>: <span class="number">0</span>&#125;).get(<span class="string">'q20_bases'</span>, <span class="number">0</span>),</span><br><span class="line">	<span class="string">'q30_bases'</span>: v[<span class="string">'summary'</span>][<span class="string">'before_filtering'</span>][<span class="string">'q30_bases'</span>] + merge_result_dict.get(key, &#123;<span class="string">'q30_bases'</span>: <span class="number">0</span>&#125;).get(<span class="string">'q30_bases'</span>, <span class="number">0</span>),</span><br><span class="line">	<span class="string">'total_reads'</span>: v[<span class="string">'summary'</span>][<span class="string">'before_filtering'</span>][<span class="string">'total_reads'</span>]+ merge_result_dict.get(key, &#123;<span class="string">'total_reads'</span>: <span class="number">0</span>&#125;).get(<span class="string">'total_reads'</span>, <span class="number">0</span>),</span><br><span class="line">	<span class="string">'dup'</span>: v[<span class="string">'summary'</span>][<span class="string">'before_filtering'</span>][<span class="string">'total_reads'</span>] * v[<span class="string">'duplication'</span>][<span class="string">'rate'</span>] + merge_result_dict.get(key, &#123;<span class="string">'dup'</span>: <span class="number">0</span>&#125;).get(<span class="string">'dup'</span>, <span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line">df_ = pd.DataFrame(merge_result_dict).T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#原始数据量</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.scatter(df_.index, df_.total_bases)</span><br><span class="line">plt.xlabel(<span class="string">"sample name"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"total_bases"</span>)</span><br><span class="line">plt.title(<span class="string">"Raw date: total_bases"</span>)</span><br><span class="line">plt.plot(df_.index, [<span class="number">9e+10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(df_.shape[<span class="number">0</span>])], <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#q20</span></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.scatter(df_.index, df_.q20_bases / df_.total_bases)</span><br><span class="line">plt.xlabel(<span class="string">"sample name"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"q20 percent"</span>)</span><br><span class="line">plt.title(<span class="string">"Raw date: q20 content"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#q30</span></span><br><span class="line">plt.figure(<span class="number">3</span>)</span><br><span class="line">plt.scatter(df_.index, df_.q30_bases / df_.total_bases)</span><br><span class="line">plt.xlabel(<span class="string">"sample name"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"q30 percent"</span>)</span><br><span class="line">plt.title(<span class="string">"Raw date: q30 content"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dup</span></span><br><span class="line">plt.figure(<span class="number">4</span>)</span><br><span class="line">plt.scatter(df_.index, df_.dup / df_.total_reads)</span><br><span class="line">plt.xlabel(<span class="string">"sample name"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"duplication rate"</span>)</span><br><span class="line">plt.title(<span class="string">"Raw date: duplication rate"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#cut dup</span></span><br><span class="line">plt.figure(<span class="number">5</span>)</span><br><span class="line">plt.scatter(df_.index, (<span class="number">1</span> - df_.dup / df_.total_reads) * df_.total_bases)</span><br><span class="line">plt.xlabel(<span class="string">"sample name"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"bases"</span>)</span><br><span class="line">plt.title(<span class="string">"cut dup: bases"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先导入相应的库，其中json和os是内置库，分别用来解析json文件以及查看文件。json格式的解析很简单，其实json可以看成是python里面的字典，下面是简单的json库使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 输出 json 数据</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>一般情况下，在当前目录运行的脚本，直接用相对路径就行，但是也有可能你的报告不在当前目录下，那么第5行和第10行的<code>&#39;./report&#39;</code>就要改成你报告所在目录的位置，同时report这个目录名也要改成你自己存放json格式的目录名。</p>
</li>
<li><p>如何合并一个sample的报告结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> result_dict.items():</span><br><span class="line">	key = k.split(<span class="string">'_'</span>)[<span class="number">0</span>]</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>这一步的工作就是合并结果，在我的结果里，虽然一个sample有时候会被分为好多个数据，但是数据的前缀的一部分都是一样的，且以<code>_</code>分割。</p>
</li>
<li><p>这个脚本提取了raw data中<code>total_bases</code>和<code>q30_bases</code>的数据，这是因为这一块是需要和测序公司核对的部分，一般公司需要交付 90G 的raw data，且Q30要80%以上。其实fastp结果里还有很多其他可以提取的数据，完全可以根据需要提取作图，还是很简单的。</p>
</li>
<li><p>最后一个图是看一下，如果去掉duplicate的数据，那么raw data还有多少数据量。</p>
</li>
<li><p>展示一个结果图。</p>
</li>
</ol>
<p><img src="/2019/07/21/批量可视化fastp输出结果/total_bases.png" alt="total_bases"></p>
<p><img src="/2019/07/21/批量可视化fastp输出结果/q20.png" alt="q20"></p>
<p><img src="/2019/07/21/批量可视化fastp输出结果/q30.png" alt="q30"></p>
<p><img src="/2019/07/21/批量可视化fastp输出结果/dup.png" alt="dup"></p>
<p><img src="/2019/07/21/批量可视化fastp输出结果/filter.png" alt="filter"></p>
<ul>
<li><p>脚本本身超级简单，我看半天实在也不知道还有哪里需要解释的，如果有什么错误或者写的不好的还请见谅了。</p>
<hr>
</li>
<li><p>水平有限，要是存在什么错误请指出，可发送邮箱至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/22/ACMG指南解读笔记（1）- PVS1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/22/ACMG指南解读笔记（1）- PVS1/" class="post-title-link" itemprop="url">ACMG指南解读笔记（1）- PVS1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-22 20:06:34" itemprop="dateCreated datePublished" datetime="2019-06-22T20:06:34+08:00">2019-06-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-24 19:50:53" itemprop="dateModified" datetime="2019-06-24T19:50:53+08:00">2019-06-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS之ACMG解读/" itemprop="url" rel="index"><span itemprop="name">我的WGS之ACMG解读</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    白纸黑字，还有中文版，其实也没啥好看不懂的，读懂它理解它并没有那么难，而我想的是怎么去实现它，限于本人专业水平有限，若有错误还请包容。<br></p>
<p>​    解读的多数内容基于ANNOVAR的注释！！！<br></p>
<hr>
<ul>
<li>原文不贴了，大体的意思我理解的就是，这个突变导致基因功能完全被破坏，那么就定义为PVS1（pathogenic very strong ，这里的数字不代表等级，只是表示序号，以示区分），同时指南也提了几个注意的点。<br></li>
<li>既然想要脚本实现，那么比较直观的方法就是流程图了，下面直接贴出这个证据实现的流程图：<br></li>
</ul>
<p><img src="/2019/06/22/ACMG指南解读笔记（1）- PVS1/pvs1.jpg" alt="原文理解图"></p>
<ul>
<li><p>这是基于InterVar源码理出来的逻辑图<br></p>
</li>
<li><p>来理解一下：<br></p>
<ul>
<li>frameshift，stopgain包含了指南中的无义突变、移码突变，说明一下，源码中还有‘nonsense’，但是该词条在ANNOVAR注释结果中是没有的（InterVar的筛选是基于ANNOVAR的），‘stopgain’可认为是‘nonsense’；同时“起始密码子变异”这一类变异在ANNOVAR中也是没有的，起始密码子在真核生物中可以认为只有AUG一种，如果发生变异了，只有一种情况，就是无法转录了，这种情况2/3能被检测出来并标为”exonic,splicing”，毕竟起始密码子就在RNA剪切位点上；“单个或多个外显子缺失”可以包含在上一种情况里；还有一个问题就是论文中作者提到了stop_less，但是在源码中似乎没有体现。<br></li>
<li>第二点就是要判断这些变异会不会导致功能丧失，这一点直接判断是很不好判断的，InterVar的做法是对ClinVar数据进行处理，挑出存在于MedGen数据库中的相关变异，过滤掉高频变异（频率大于5%）以及一些结果矛盾的变异。最后挑出的基因列表里，每个gene中至少有一个变异在Clinvar中为“pathogenic”，并与ExAC对<a href="https://www.nature.com/articles/nature19057" target="_blank" rel="noopener">LOF容忍度打分</a>很低的基因取了并集，最后得到了这么一个list（挂在github上了）。<br></li>
<li>第三点，如果是在经典的剪接位点发生突变，这一点判断方法，主要是基于dbscSNV的打分来判断的，阈值是0.6，数据库在ANNOVAR上直接可以下载。<br></li>
<li>同时指南有几个附加注意点：<br><ul>
<li>第一点我的解读就是判断某些突变的特异性，比如只有杂合错义突变时才致病, 而杂合无功能变异却是良性的，这个例子本身就是很特殊的，如果真碰到这个情况，且这种情况已知，那么一开始就可以特异性找出来或筛掉相关变异，如果一开始不知道，这一步也只是让某些变异有害性增强，在复查的时候也可以筛掉，所以影响不大。<br></li>
<li>第二点主要体现在对于exon的选取，作者筛掉了在第一和最后一个exon上的变异，并在下一步过滤了倒数第一个exon（InterVar提供了相关列表，挂在github上了）上靠近3‘端50bp的变异，这里不太明白的是为什么要筛掉第一个exon上的变异，指南中似乎没有提到相关的要求，而InterVar论文中也没有相关说明；同样的指南有提到倒数第二个exon，这里也没有体现。<br></li>
<li>第三点的一部分通过dbscSNV体现，其余的无法比较好的直接判断，所以没有体现，第四点，第五点同理，不好判断。<br></li>
</ul>
</li>
</ul>
</li>
<li><p>从上面的分析可以得到，对于ACMG指南，解读和判断经常是很难面面俱到的，有些时候只能尽量通过一些方法来辅助判断，但是在使用这些辅助手段的时候就要慎重，辅助手段本身是存在一定的偏差的。<br></p>
</li>
<li><p>总结一下我的问题和我觉得可以改进的地方：<br></p>
<ol>
<li>起始密码子第三个碱基发生突变的时候，这种情况InterVar是如何考虑的，不知道是我没看明白还是InterVar没有考虑到，如果是后者，那么就可以针对改进了（即使这种情况可能性可能很低）。<br></li>
<li>stop_less这种变异是不是可能会造成功能丧失，作者论文中提到了，从我的逻辑来说应该是不太可能会的。<br></li>
<li>功能缺失基因列表如果能采用Clinvar结合HGMD，那么应该能更准确一点，这一点有条件的小伙伴完全可以考虑一下，更新list的。<br></li>
<li>不太明白为什么要过滤掉第一个exon上的变异，以及为什么没有过滤掉倒数第二个exon上的靠近3‘端50bp的变异。<br></li>
</ol>
</li>
<li><p>以上问题非常欢迎各位交流指导！！！<br></p>
</li>
</ul>
<hr>
<p>水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！<br></p>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/21/ACMG指南解读笔记（0）- 定个小目标/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/21/ACMG指南解读笔记（0）- 定个小目标/" class="post-title-link" itemprop="url">ACMG指南解读笔记（0）- 定个小目标</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-21 16:49:41" itemprop="dateCreated datePublished" datetime="2019-06-21T16:49:41+08:00">2019-06-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-22 23:34:41" itemprop="dateModified" datetime="2019-06-22T23:34:41+08:00">2019-06-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS之ACMG解读/" itemprop="url" rel="index"><span itemprop="name">我的WGS之ACMG解读</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>好久没有更新内容，照理来说对于call出来的SNVs/INDELs，下一步的工作就是筛选了，一般的筛选方式大体会有这些步骤：<br></p>
<ul>
<li><p>保留数据库中已报道的致病位点（Clinvar、HGMD）<br></p>
</li>
<li><p>过库筛选（人群频率数据库）<br></p>
</li>
<li><p>保留coding区域（一般是exonic和splicing，下同）<br></p>
</li>
<li><p>保留有害位点（通过预测软件打分）<br></p>
</li>
<li><p>去除非高度保守区同义突变（GERP++等判别）<br></p>
</li>
<li><p>遗传模式过滤<br></p>
</li>
<li><p>以及其他<br></p>
</li>
</ul>
</li>
<li><p>如果在某疾病患者中（指单基因遗传病，符合孟德尔遗传定律，下同），找到了该疾病已经报道的致病突变位点，那大体来说，这个位点就会被判断为该患者的致病突变。<br></p>
</li>
<li><p>在这里，我们一般更认可HGMD中收录的记录，相对来说，Clinvar就是一个比较“脏”的数据库，因为这个公共数据库中的位点信息是大家都可以上传的，没有经过专门的筛选和“清洗”，真实性相对较差。而反过来，Clinvar是一个免费数据库，可以随时下载使用；HGMD的专业版收费是真的高，一般的课题组怕是很难吃得消，HGMD的公开版不收录近三年的信息（别看三年，差异很大，尤其是现在科学进展越来越快），只提供检索，不提供下载。所以要是买不起HGMD，Clinvar也就将就一点凑活用吧。<br></p>
</li>
<li><p>但是，经过上面的筛选，其实大多数病例的致病原因都是无法解释的。那么就需要我们常规的一些筛选策略了。其中首选的就是基于人群频率数据库的过滤。我们一般认为，一个变异在多数人身上存在，那这个变异应该是良性的（benign），看文献，绝大多数的方法里都有这一步。<br></p>
</li>
<li><p>Annovar提供了很多的人群频率数据库，那么我们怎么选呢？<br></p>
<ul>
<li>考虑到种族特异性，尽量选择东亚人群数据库（1000gEAS等）<br></li>
<li>尽量选择多个数据库（1000g，ESP6500等）<br></li>
<li>尽量选择正常人群数据库<br></li>
<li>考虑选择大家常用的知名数据库（1000g，gnomad，ESP6500等）<br></li>
</ul>
</li>
<li><p>阈值的话可以考虑5%（常见变异和稀有变异的交界），1%（很多文献都是这个值），0.5%（稀有突变和罕见突变的交界），你要说区别有多大，得看你疾病的发病率了，我们做罕见疾病，筛选到后来，基本剩下的位点的人群频率都比上面三个数小，所以区别不大。但这一步能帮你筛掉很多的变异。<br></p>
</li>
<li><p>保留coding是因为noncoding的变异没有很好的筛选策略，而80%的遗传病病因可以用coding区突变来解释（教科书上这么说的），所以现在做WES的很多。<br></p>
</li>
<li><p>通过预测软件对位点的有害性进行打分。SIFT，Polyphen，MutationTaster，CADD是我们常用的四个软件，一般说半数以上预测有害，就认为有害。当然，既然是预测软件，就存在一定的偏差，可能会漏掉一些不常规的有害变异，或者保留一些良性变异。<br></p>
</li>
<li><p>同义突变不改变氨基酸，但目前的研究发现，并不是说同义突变就不致病，但是对于大多数同义突变，尤其是非保守区的同义突变，我们还是认为它是良性的。<br></p>
</li>
<li><p>遗传模式是基于家系数据进行判断致病性的一个比较好的方式。比如，当该疾病只在患者身上有临床表现，我们就考虑纯合突变，新发突变或复合杂合突变。<br></p>
</li>
<li><p>同时也会着重考虑OMIM上该疾病已经报道的相关基因上的变异位点。<br></p>
</li>
<li><p>还有一些其他的我也没考虑到的过滤方式（欢迎大家发邮件交流补充！！！）<br></p>
</li>
</ul>
<hr>
<ul>
<li>可能有一些朋友要问，我为什么要根据上面的条件过滤？依据又是什么？？还有什么值得注意的地方？？？有没有什么金标准？？？？<br></li>
<li>说到金标准，还真是有的。<br></li>
<li>2015年的时候，由美国医学遗传学与基因组学学会(The American College of Medical Genetics and Genomics, ACMG)，分子病理协会(the Association for Molecular Pathology, AMP)和美国病理学家协会(the College of American<br>Pathologists, CAP)的代表撰写修订了序列变异解读的标准和指南，发表在nature子刊GIM上，指南原文<a href="https://www.acmg.net/docs/Standards_Guidelines_for_the_Interpretation_of_Sequence_Variants.pdf" target="_blank" rel="noopener">在这里</a>能看到，当然也可以去GIM上搜。<br></li>
<li>对于遗传专业术语不太了解的同学，可能在解读原版指南的时候很痛苦。那也不用怕，在该指南发布后，国内外超过30家单位的几十位业界大佬共同翻译了该指南，链接在<a href="http://acmg.cbgc.org.cn/doku.php" target="_blank" rel="noopener">这里</a>，这样至少在解读上轻松了一半。<br></li>
<li>在解读完该指南后，你就会发现，上述筛选条件，基本都有指南的影子。毕竟该指南是号称可直接应用于临床，所以理解该指南对于变异的筛选还是很有帮助的。<br></li>
<li>但问题也是有的，以下所列都是个人观点，若是理解不当望指出：<br><ul>
<li>临床是临床，科研是科研，临床和科研的目的是不一样的，如果全用这套指南去科研，怕是很难找出新的位点或基因。<br></li>
<li>该指南甚是全面了，但是很多证据的解读，不同的人怕是存在分歧的。<br></li>
<li>该指南在理解上可能不是很难，但实际去判断就存在很大的困难了。<br></li>
<li>2017年的时候annovar的作者王凯大神根据指南写了一个软件InterVar，发表在AJHG上，原文链接在<a href="https://www.sciencedirect.com/science/article/pii/S0002929717300046?via%3Dihub" target="_blank" rel="noopener">这里</a>，软件挂在github上，链接在<a href="https://github.com/WGLab/InterVar" target="_blank" rel="noopener">这里</a>，网页版软件的链接在<a href="http://wintervar.wglab.org/" target="_blank" rel="noopener">这里</a>，结果文件intervar_20180118在annovar上直接可以下载，方法可参考我之前的<a href="https://tongshiyuan.github.io/2019/06/18/WGS分析笔记%EF%BC%885%EF%BC%89-%20annotation/">文章</a>。只能说大神不愧是大神，真是一件喜大普奔的事情。但是存在一些问题：<br><ul>
<li>由于版权问题，作者用到的结果是基于Clinvar而不是HGDM<br></li>
<li>由于不同的疾病本身存在的特异性，加之指南有些证据难以通过软件进行判断，intervar一些证据是默认为False的，需要手动判断<br></li>
<li>网页版intervar虽然能手动较为直观的设定特异性参数，但是不利于批量判断，且不含indel信息<br></li>
</ul>
</li>
</ul>
</li>
<li>本着加深学习的目的，我决定逐条解读这些证据（共28个证据，16个角度）。本来想自己一个人这么做的，发现难度不小，有些证据我真的很难正确的解读，想组队讨论，又找不到又闲又感兴趣的（身边做这个的人太少啦，所以特别希望能有人一起交流讨论）。所以就打算写成系列文章挂出来，接受广大人民群众的diss。<br></li>
<li>我会基于中文版ACMG指南，参考InterVar文章和源码，较为详细的解读每一个证据（flag是立下来了，督促自己！），然后尽量重构Intervar。最后参考<a href="https://www.nature.com/articles/gim201737" target="_blank" rel="noopener">Sherloc: a comprehensive refinement of the ACMG–AMP variant classification criteria</a>（基于指南的分析框架，让指南更便于实现）进行调整。<br></li>
</ul>
<hr>
<p>水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！<br></p>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/18/fastqc的线程与速度测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/18/fastqc的线程与速度测试/" class="post-title-link" itemprop="url">fastqc的线程与速度测试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 13:49:45" itemprop="dateCreated datePublished" datetime="2019-06-18T13:49:45+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-22 23:34:50" itemprop="dateModified" datetime="2019-06-22T23:34:50+08:00">2019-06-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WGS工具测试记录/" itemprop="url" rel="index"><span itemprop="name">WGS工具测试记录</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;之前文章写了bowtie2和bwa的比较，发完之后立刻被师姐批评指正了，然后师姐又给我补充了一个知识，就是不同软件都有它的最佳线程数，不是线程越高就跑的越快，直接一个软件定个24线程是不合理的。至于这个最佳线程数是多少，说明书要是没有的话，要么自己评测，要么问问作者。<br><br>&emsp;&emsp;我看了bwa的说明书，没有相关说明，粗略的查了一下帖子也没看到。让我自己评测一下bwa的速度，我是嫌麻烦的，于是我就尝试着评测一下fastqc。因为一开始我就是加大了这个的使用线程，也没考虑是不是有必要，而且这个速度也快，操作也方便，所以做个简单的速度测试。<br><br>&emsp;&emsp;软件是fastqc，选用的对象是一个cleaned data，还是比较大的，测试脚本如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ time fastqc -o singleout1/ -t 1 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout3/ -t 3 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout6/ -t 6 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout8/ -t 8 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout12/ -t 12 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout16/ -t 16 1.fq.gz</span><br><span class="line">$ time fastqc -o singleout24/ -t 24 1.fq.gz</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果如下：<br><img src="/2019/06/18/fastqc的线程与速度测试/1.png" alt="1线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/2.png" alt="3线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/3.png" alt="6线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/4.png" alt="8线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/5.png" alt="12线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/6.png" alt="16线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/7.png" alt="24线程"><br>&emsp;&emsp;看到这个结果，我……有点吃惊的，居然都是一样的。那我脚本里写那么大的线程意义何在？<br><br>&emsp;&emsp;所以我又加了一个测试，测试多个样本下的不同线程的速度，当前文件夹下有4个fq文件。测试脚本如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ time fastqc -o allout1/ -t 1 *.fq.gz</span><br><span class="line">$ time fastqc -o allout6/ -t 6 *.fq.gz</span><br><span class="line">$ time fastqc -o allout12/ -t 12 *.fq.gz</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果如下：<br><br><img src="/2019/06/18/fastqc的线程与速度测试/8.png" alt="12线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/9.png" alt="6线程"><br><img src="/2019/06/18/fastqc的线程与速度测试/10.png" alt="1线程"></p>
<p>&emsp;&emsp;我想大家已经看出来了，对于单个样本，fastqc每增加一个线程并不改变运行速度，但是对于多个输入文件，每增加一个线程会多并行跑一个输入文件，就是说，比如输入四个文件，四线程会同时跑四个文件，单线程只能一个一个跑。<br><br>&emsp;&emsp;能得到一个结论还是挺开心的，那么以后在fastqc线程选择的时候也就知道多少的线程数是有必要的。<br><br>&emsp;&emsp;水平有限，要是存在什么错误请指出，可发送邮箱至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！<br></p>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/18/WGS分析笔记（5）- annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/18/WGS分析笔记（5）- annotation/" class="post-title-link" itemprop="url">WGS分析笔记（5）- annotation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 12:52:03" itemprop="dateCreated datePublished" datetime="2019-06-18T12:52:03+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-22 19:34:33" itemprop="dateModified" datetime="2019-09-22T19:34:33+08:00">2019-09-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS/" itemprop="url" rel="index"><span itemprop="name">我的WGS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp; 在找到很多变异以后（本文具体指的是snv以及indel），我们需要做的就是进行注释了，这是因为无论WGS还是WES，都会call出大量的变异。即使是一个正常人，也会有百万数量级的变异（详见<a href="https://tongshiyuan.github.io/2019/06/18/WGS分析笔记%EF%BC%884%EF%BC%89-%20Call%20SNVs%20indels/">上一章</a>），而我们需要做的是把其中可能有害的变异找出来。因此对于这么多的变异，就需要通过注释信息来筛选了（不同于call snv/indel以后的筛选，那是依据变异本身的可信度进行筛选的）。<br><br>&emsp;&emsp; 对于不同的研究目的，目前用的注释软件还是不少的，有专门针对肿瘤数据的注释软件（如oncotator等），也有孟德尔遗传疾病测序数据常用的annovar、vep等。<br><br>&emsp;&emsp; 本文主要讲的是通过annovar，对vcf文件进行注释，个人觉得annovar特别好用简单，说明书也写得很好，即使是我这种看了英语头晕的人，也能看的比较明白。<br></p>
<p>&emsp;&emsp; 比较一下annovar和vep，annovar软件是需要先申请再下载的，对于研究机构是免费的，对商业机构是收费的，只要你拿学邮去申请，应该就没有问题。而vep是免费的，但是呢，安装起来超级麻烦，本文虽然不用vep，但会在后面附上我当初安装vep的笔记。<br></p>
<p>&emsp;&emsp;annovar很人性化的一点是，当你下载到软件以后，直接解压就能用了，不用安装。而你需要注释什么数据库，按照官网说明书的词条直接下载就行。<br><br>&emsp;&emsp;本文主要讲述我在做课题的时候是如何使用的，具体的细节可以参考<a href="http://annovar.openbioinformatics.org/en/latest/" target="_blank" rel="noopener">官网说明书</a>或者别的大神们的使用笔记。<br><br>&emsp;&emsp;首先是下载数据，annovar提供了大量的数据库，可以单独下载也可以批量下载，主要是来源于annovar自己网站以及ucsc的，你要是批量下载是完全没有必要的，因为一个数据库可能有很多的版本，也有很多数据库是你不需要的，还有一些数据库所占空间那是相当的大。举几个我常用的数据库为例（我只是举例一些，建议是看看说明书根据需要下载）。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#注释基因</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar refGene humandb/</span><br><span class="line">#注释人群频率</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar esp6500siv2_all humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar exac03 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar gnomad_genome humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar 1000g2015aug humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar popfreq_max_20150413 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar popfreq_all_20150413 humandb/</span><br><span class="line">#预测打分</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar mcap13 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar revel humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar gerp++gt2 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar cadd13 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar dbnsfp35a humandb/</span><br><span class="line"># dbsnp</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 snp151 humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar avsnp150 humandb/</span><br><span class="line"># 致病位点公共数据库</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 gwasCatalog humandb/</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 -webfrom annovar clinvar_20190305 humandb/</span><br><span class="line">#区域注释</span><br><span class="line">$ perl annotate_variation.pl -downdb -buildver hg19 cytoBand humandb/</span><br><span class="line"># 稍微注意一下 humandb/ 是当前目录下有这么一个文件夹，用来放数据库的，这个路径关系到你用的时候的路径，你放在哪，用的时候把路径改成哪就行</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后是输入格式的转换，对于注释所需的输入文件，只需要前五列按照<code>avinput</code>的要求就行了，格式如下。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#分别以tab分隔</span><br><span class="line">染色体位置	起始位点    终止位点    参考基因组碱基    突变碱基</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在注释完以后是不会保留原有的五列以外的内容的，转换脚本如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl convert2annovar.pl -format vcf4old in.vcf &gt; out.avinput</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这个脚本除了把<code>vcf</code>转换为<code>avinput</code>以外，还会把一些多等位位点转换为单等位位点来注释，而格式之所以选用<code>vcf4old</code>，是因为我的输入格式是家系merge的vcf，一个vcf文件里有一家人的信息，如果是单个样本的话，直接用<code>vcf4</code>就行了。<br><br>&emsp;&emsp;用这种方式得到的结果就像我说的，注释完以后就没有保留 genotype等信息，除了前五列就只剩注释信息了。当然，也可以不转换格式，直接用<code>vcf</code>作为输入格式了，那么注释结果以标签的方式插入<code>vcf</code>文件之中，但是这样的话，会导致输出结果异常的占空间，因为，每一个数据库的头文件会反复出现在每一行被注释的变异中。提供参考脚本如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 输入是vcf文件，要加上参数-vcfinput</span><br><span class="line">$ perl table_annovar.pl in.vcf /path/humandb/ -buildver hg19 -out myanno -remove -protocol refGene,cytoBand,exac03,avsnp147,dbnsfp30a -operation g,r,f,f,f -nastring . -vcfinput</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虽然提供了这种方法，但我却是不建议的，尤其是我以WGS的文件作为输入，会使输出文件占很大的空间，但我又想保留 genotype信息，因为后面我需要这个信息判断变异的显隐性，这对于筛选是很关键的，那怎么办呢？<br><br>&emsp;&emsp;我想到的办法就是，在转换格式的时候，添加参数<code>-includeinfo</code>和<code>-comment</code>，前者的作用保留了genotype信息，后者保留了vcf的头文件。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl convert2annovar.pl -format vcf4old in.vcf -outfile out.avinput -comment -includeinfo</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;转换完格式就是注释了，虽然annovar提供了多种注释方式，但是我们一般都是批量注释，即像上面那个注释的例子一样，下面来简单说一下怎么批量注释。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ table_annovar.pl out.avinput /your/path/of/humandb/ \</span><br><span class="line">	--buildver hg19 -out /your/path/of/outfile -remove \</span><br><span class="line">	-protocol refGene,cytoBand,EAS.sites.2015_08,ALL.sites.2015_08,kaviar_20150923,hrcr1,cg69,gnomad_genome,exac03,exac03nonpsych,esp6500siv2_all,cg46 \</span><br><span class="line">	-operation g,r,f,f,f,f,f,f,f,f,f,f \</span><br><span class="line">	-nastring . --thread 12</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;来详细说一下我这个脚本有什么需要注意的地方，而我又是怎么应用于实际课题中的。<br><br>&emsp;&emsp;首先是out.avinput，就是上面转换之后的输出文件；之后跟着的就是我们下载数据库的目录；我用的是hg19的参考基因组；<code>-out</code>是输出文件的路径和输出文件的前缀；<code>-remove</code>表示删除注释过程中的临时文件;<code>-protocol</code>表示注释使用的数据库，用逗号隔开；<code>-operation</code> 表示对应顺序的数据库的类型（g代表gene-based、r代表region-based、f代表filter-based，可对照说明书），用逗号隔开，与<code>-protocol</code>顺序一一对应；<code>-nastring</code> 表示用点号替代缺省的值。<br><br>&emsp;&emsp;annovar其实提供了好多个<code>gene-based</code>数据库下载，refGene是NCBI提供的，还有ensembl、UCSC提供的ensGene、knowGene，这三个数据库是有所差别的，至于怎么选择，建议就和使用的参考基因组来源一致即可，比如我用的是NCBI上下载的参考基因组，那么就用refGene。<br><br>&emsp;&emsp;<code>-csvout</code> 表示最后输出.csv文件，使用这个参数得到的是csv格式的文件，可以直接用excel打开，但是我没有使用，输出是tab分隔的txt文件，方便后续我写脚本处理。为什么“,”分隔的csv文件不适合处理呢？那是因为refgene的注释结果也是逗号分隔的，在分析的时候就会出现问题。<br><br>&emsp;&emsp;<code>--thread</code>是线程数，当然线程数越高注释速度越快。<br><br>&emsp;&emsp;到了这一步以后，其实结果还是前五列avinput的内容，后面是注释的内容，genotype的信息还是没有掉了，这个时候就加一步，来解决一下这个问题。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -v &quot;##&quot; out.avinput | cut -f1-9 --complement &gt; gt.txt</span><br><span class="line">$ paste hg19_multianno.txt gt.txt &gt; merge.anno.txt</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很简单的两行命令，第一行提取了avinput文件里的genotype信息，然后第二行merge这个信息到注释完的文件上。这样得到的结果呢，又有注释信息，又有genotype信息，就很方便进行trio分析。<br><br>&emsp;&emsp;到这里其实就差不多了，可以进行下一步的筛选了，但是实际情况中，我们用到的数据库可能不止annovar提供的这些。毕竟annovar提供的数据库都是公开的数据库，而且对于日新月异的预测数据库等，annovar作者也不能做到每一种都去收录，如果你有一些自己下载的数据库，你该怎么利用annovar去注释呢？<br><br>&emsp;&emsp;这一类的数据库很多，比如omim需要申请才能下载，HGMD专业版需要付费订阅，这些annovar都是没有提供的。但是这些数据库在孟德尔遗传疾病中是很具有参考价值的，由于这两个都不能直接下载获得，这里也不详述，以两个近期发表在Nature Genetic上的公开的预测数据库为例，简述一下简单的方法构建自己的数据库。<br><br>&emsp;&emsp;annovar注释变异有两种注释方式，一个是基于区域，一个是基于位点，<a href="https://www.nature.com/articles/s41588-018-0294-6" target="_blank" rel="noopener">CCRS</a>就是一个基于区域的有害性预测打分工具，其数据可在这里下载，分为<a href="https://s3.us-east-2.amazonaws.com/ccrs/ccrs/ccrs.autosomes.v2.20180420.bed.gz" target="_blank" rel="noopener">常染色体</a>和<a href="https://s3.us-east-2.amazonaws.com/ccrs/ccrs/ccrs.xchrom.v2.20180420.bed.gz" target="_blank" rel="noopener">X染色体</a>；<a href="https://www.nature.com/articles/s41588-019-0348-4" target="_blank" rel="noopener">S-CAP</a>就是一个基于位点的splicing 区域有害性预测工具，其数据可以在<a href="http://bejerano.stanford.edu/scap/" target="_blank" rel="noopener">这里</a>下载。<br></p>
<h5 id="CCRS"><a href="#CCRS" class="headerlink" title="CCRS"></a>CCRS</h5><p>&emsp;&emsp;由于是基于区域的，那么在<code>-operation</code>参数里面呢是<code>r</code>，然后呢从网上下载下来的是一个bed文件，截取前十行，长这样。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/1.png" alt="ccrs"></p>
<p>&emsp;&emsp;这些信息其实我们只需要ccr_pct这一列的打分，为了方便起见，完全可以只保留前四列的内容，不然注释完会把所有前三列以后的内容都加到注释结果文件里。<br><br>&emsp;&emsp;那么这么一个文件是不能直接拿来用的，第一步就是改名。下载过annovar提供的数据库后可以知道，annovar使用的数据库都有自己的命名方式，这里的话直接改成 <code>hg19_ccrs.txt</code>即可，<code>hg19</code>表示所使用的参考基因组版本，因为CCRS 的坐标是基于hg19的，所以这里是hg19，ccrs就是<code>-protocol</code>参数里的标识符了，然后以<code>.txt</code>作为后缀。<br><br>&emsp;&emsp;然后是修改格式，一开始我用的方法是参考annovar提供的<code>region-based</code>数据库的格式，然后修改CCRS的格式。后来我发现这是行不通的，因为现成的数据库格式差别有点大，那么就只能看源码了。但其实我是不会perl的，在师姐的帮助下，完美的解决了这个问题。<br><br>&emsp;&emsp;虽然我们是使用<code>table_annovar.pl</code>进行注释的，实际上对于<code>region-based</code>数据库的注释是调用<code>annotate_variation.pl</code>，所以需要修改<code>annotate_variation.pl</code>的源码。在2998行我们可以看到，其实对于不同<code>region-based</code>数据库，都是有预设的。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/2.png" alt="annotate_variation.pl"></p>
<p>&emsp;&emsp;所以根据CCRS的格式，我们可以在这里添加一个预设语句块。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/3.png" alt="ccrs预设"></p>
<p>&emsp;&emsp;当然也可以根据最后一个<code>else语句块</code>修改CCRS的格式<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/4.png" alt="else语句块"></p>
<p>&emsp;&emsp;从这个语句块可以看出来，只需要在CCRS原始文件前面添加一列内容，以<code>tab</code>隔开，就行，添加啥也都无所谓，这里就不赘述了。<br></p>
<h5 id="S-CAP"><a href="#S-CAP" class="headerlink" title="S-CAP"></a>S-CAP</h5><p>&emsp;&emsp;由于是基于位点的，那么在<code>-operation</code>参数里面呢是<code>f</code>，然后呢从网上下载下来的文件，一共有八个文件（不同区域不同标准，可以参考论文），任意选取一个截取前十行，长这样。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/5.png" alt="S-CAP"></p>
<p>&emsp;&emsp;这里我已经把名字修改了，如果大家有查看过<code>filter-based</code>数据库，大抵都是这个格式，染色染位置、起始位置、结束位置、参考碱基、突变碱基、要注释的内容（可以是多列），以<code>tab</code>隔开。这里可以发现，少了一列结束位置，那是因为论文只针对snp，所以不用start、end表示也可以，这里用一个简单的语句就可以解决这一点。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &quot;\t&quot; &apos;&#123;print $1&quot;\t&quot;$2&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t&quot;$4&quot;\t&quot;$5&#125;&apos; scap3cr.txt &gt; hg19_scap3cr.txt</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是注意，这样是不够的，如果你看了这个论文，你会发现，这是预测splicing区域有害性的打分，更重要的是，论文中对splicing区域的划分和annovar默认的aplicing区域是不一样的！！！<br><br>&emsp;&emsp;在annovar里头，splicing的区域是2bp，也就是图中的1和4.<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/6.png" alt="splicing"><br>&emsp;&emsp;但是论文中作者为了更好的预测有害性，用了整整100bp的长度（内含子外显子各50bp），所以仅仅用annovar默认的splicing区域大小就太浪费这个打分了，那怎么扩大这个范围呢？<br><br>&emsp;&emsp;其实如果仔细看annovar说明书我们会发现，在<code>annotate_variation.pl</code>的脚本中有一个参数<code>--splicing_threshold</code>，可以控制splicing的区域大小，默认是2，但是我们用的是<code>table_annovar.pl</code>的脚本进行注释，虽然是调用<code>annotate_variation.pl</code>，但是却没有了<code>--splicing_threshold</code>这个参数，看来又只能改源码了。<br><br>&emsp;&emsp;在<code>table_annovar.pl</code>第380行（不同版本可能不太一样），有这么一句话。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（5）- annotation/7.png" alt="--splicing_threshold"></p>
<p>&emsp;&emsp;里面在调用<code>annotate_variation.pl</code>的时候，直接给了<code>--splicing_threshold</code>这个参数，只要把后面的数字改成50就好了（原来是2）。至于怎么建立索引可以参考<a href="https://mp.weixin.qq.com/s/_h-EkT9YvffSOuViYT_gGQ" target="_blank" rel="noopener">这里</a>，是否建立索引会影响注释速度，但不会影响结果。<br><br>&emsp;&emsp;至此，这一部分内容就完了，我在实践中也就是这么使用的，具体的根据需要可以好好读一读annovar的官网说明。<br></p>
<hr>
<p>&emsp;&emsp;水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！</p>
<h3 id="附（vep安装笔记）"><a href="#附（vep安装笔记）" class="headerlink" title="附（vep安装笔记）"></a>附（vep安装笔记）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#由于我用的是ubuntu server 18.04，不同linux发行版本之间的安装可能存在差异</span><br><span class="line">	$ git clone https://github.com/Ensembl/ensembl-vep.git</span><br><span class="line">	$ cd ensembl-vep</span><br><span class="line">	$ perl -MCPAN -e shell</span><br><span class="line">	$ cpan&gt;install DBI</span><br><span class="line">	$ cpan&gt;install Bio::DB::HTS</span><br><span class="line">	$ cpan&gt;install LWP::Simple </span><br><span class="line">	$ cpan&gt;install LWP::Protocol::https</span><br><span class="line">	$ cpan&gt;install Archive::Extract</span><br><span class="line">	$ cpan&gt;install Archive::Tar</span><br><span class="line">	$ cpan&gt;install Archive::Zip</span><br><span class="line">	$ cpan&gt;install CGI</span><br><span class="line">	$ cpan&gt;install Time::HiRes</span><br><span class="line">	$ cpan&gt;install DBD::mysql</span><br><span class="line">	$ cpan&gt;q</span><br><span class="line">	$ sudo apt-get install libdbd-mysql-perl</span><br><span class="line">	$ perl INSTALL.pl</span><br><span class="line">	$ perl INSTALL.pl --AUTO af --SPECIES homo_sapiens --ASSEMBLY GRCh37 --DESTDIR /your/path/of/vepdatabase/ --CACHEDIR /your/path/of/vepdatabase/</span><br><span class="line">	$ perl convert_cache.pl --species homo_sapiens --version 94_GRCh37 --dir /your/path/of/vepdatabase/</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/18/WGS分析笔记（4）- Call SNVs indels/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/18/WGS分析笔记（4）- Call SNVs indels/" class="post-title-link" itemprop="url">WGS分析笔记（4）- Call SNVs/indels</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 12:51:38" itemprop="dateCreated datePublished" datetime="2019-06-18T12:51:38+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-22 23:35:33" itemprop="dateModified" datetime="2019-06-22T23:35:33+08:00">2019-06-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS/" itemprop="url" rel="index"><span itemprop="name">我的WGS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直忙期末汇报和脚本编写，没来的及接着往下写文章，年前把这一块写了，然后再往下的分析流程就比较特异性了，做一步写一步那种，相对于这种已经常规化的流程（除了一些细节上的差异，别的都是大同小异的了），再往下的可能就不是很常规的分析手段了，不同的实验室有不同的分析方法，希望能够有大佬提点意见，多多交流。<br></p>
<hr>
<h3 id="“突变”区别"><a href="#“突变”区别" class="headerlink" title="“突变”区别"></a>“突变”区别</h3><p>&emsp;&emsp;对于WGS的数据，在处理完bam文件以后，就是call variations了，之后所有的工作其实都是针对variations进行分析，那么说到变异呢，其实中文的“变异”在英文里对应多个单词，经常看到傻傻分不清，这里稍微区别一下。<br><br>&emsp;&emsp;<em>mutation：核苷酸序列的永久性改变（来源于ACMG），在人群中小于1%或5%（来源于北大生物信息学公开课）<br></em><br>&emsp;&emsp;<em>polymorphism：在人群中频率超过1%（来源于ACMG），或超过5%（来源于北大生物信息学公开课）<br></em><br>&emsp;&emsp;<em>variation/variant：以上两个的总和（来源于北大生物信息学公开课）</em><br></p>
<h3 id="变异类型"><a href="#变异类型" class="headerlink" title="变异类型"></a>变异类型</h3><p>&emsp;&emsp;我们一般所说的variations主要有四大类：SNV，INDEL，SV，CNV。(有些call变异软件也会支持MNV的calling，但是我们很少考虑这一类变异)<br><br>&emsp;&emsp;&emsp;&emsp;SNV即单核苷酸位点变异（single nucleotide variants）<br><br>&emsp;&emsp;&emsp;&emsp;INDEL即小片段插入缺失（insertion and deletion）<br><br>&emsp;&emsp;&emsp;&emsp;SV即结构变异（structural variation）<br><br>&emsp;&emsp;&emsp;&emsp;CNV即拷贝数变异（copy number variation）<br></p>
<h3 id="SNV与SNP"><a href="#SNV与SNP" class="headerlink" title="SNV与SNP"></a>SNV与SNP</h3><p>&emsp;&emsp;说到SNV，可能大家也经常看到SNP（single nucleotide polymorphism），同样是混淆使用，这俩其实还是有一些区别的，看到上面对变异的区分，其实也能看出这俩的区别来：<br><br>&emsp;&emsp;一般SNP是二态的，SNV没有这样的限制，如果在一个物种中该单碱基变异的频率达到一定水平（1%）就叫SNP，而频率未知（比如仅仅在一个个体中发现）就叫SNV，SNV包含SNP。<br></p>
<h3 id="变异简述"><a href="#变异简述" class="headerlink" title="变异简述"></a>变异简述</h3><p>&emsp;&emsp;人基因组通常有4.1 - 5.0M的变异，但是99.9%都是由SNV和short indel造成。<br><br>&emsp;&emsp;通常，一个人全基因组内会有约 3.6 - 4.4 M 个 SNVs，绝大数（大于 95%）的高频（群体中等位基因频率大于 5%）的 SNP 在 dbSNP中有记录，高频的SNP一般都不是致病的主要突变位点。<br><br>&emsp;&emsp;通常，一个人全基因组内会有约 600K 的 Indel（&lt;50bp的插入缺失为small indel）。<br><br>&emsp;&emsp;编码区或剪接位点处发生的插入缺失都可能会改变蛋白的翻译。<br></p>
<h4 id="SV"><a href="#SV" class="headerlink" title="SV"></a>SV</h4><p>&emsp;&emsp;结构变异指的是在基因组上一些大的结构性的变异，比如大片段丢失（deletion）、大片段插入（insertion）、大片段重复（duplication）、拷贝数变异（copy number variants）、倒位（inversion）、易位（translocation）。一般来说，结构变异涉及的序列长度在1kb到3Mb之间。结构变异普遍存在于人类基因组中，是个人差异和一些疾病易感性的来源。结构变异还可能导致融合基因的发生，一些癌症已经证实和结构变异导致的基因融合事件有关。<br></p>
<h4 id="CNV"><a href="#CNV" class="headerlink" title="CNV"></a>CNV</h4><p>&emsp;&emsp;拷贝数变异指的是基因组上大片段序列拷贝数的增加或者减少，可分为缺失（deletion）和重复(duplication)两种类型，是一种重要的分子机制。CNV能够导致孟德尔遗传病与罕见疾病, 同时与包括癌症在内的复杂疾病相关，因此对于染色体水平的缺失、扩增的研究已经成为疾病研究热点。<br></p>
<p>以上数据在不同的数据库或文献上可能有所差异，但相去不远，具体的变异分类以及分布就不详述，可参考一些文献，下面说说怎么进行其中的SNV和indel的检测。<br></p>
<hr>
<p>&emsp;&emsp;以下我将提供两种分析方式的脚本（<a href="https://github.com/google/deepvariant" target="_blank" rel="noopener">DeepVariant</a>以及<a href="http://www.htslib.org/doc/bcftools.html" target="_blank" rel="noopener">bcftools</a>）和流程，为啥没有GATK？因为我觉得黄老师的这篇<a href="https://www.jianshu.com/p/0b0c4ab4c38a" target="_blank" rel="noopener">GATK分析流程</a>写得已经很好了，大家可以参考一下。<br></p>
<h3 id="Bcftools"><a href="#Bcftools" class="headerlink" title="Bcftools"></a>Bcftools</h3><p>&emsp;&emsp;与旧版的samtools+bcftools不同，作者为了避免bcftools和samtools的版本不同导致的不兼容，新版的bcftools可以自己完成call snv/indel的工作。<br><br>&emsp;&emsp;使用bcftools进行变异检测，一般分为三部曲，分别为三个模块mpileup、call、filter，当然，我们一般也不会分三步进行操作，而是使用管道（pipeline）进行编写脚本，这样能减少产生一些不必要的过程文件，同时提高自动化和效率，下面是我的实际使用脚本。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ bcftools mpileup --threads 12 -q 20 -Q 20 -Ou -f /your/path/of/reference /your/bamfile/after/sorted.merged.markdup | bcftools call --threads 12 -vm -Ov | bcftools filter --threads 12 -s FILTER -g 10 -G 10 -i &quot;%QUAL&gt;20 &amp;&amp; DP&gt;6 &amp;&amp; MQ&gt;50 &amp;&amp; (DP4[2]+DP4[3])&gt;4&quot; &gt; raw.tmp.vcf</span><br><span class="line">## bcftools mpileup检测变异;</span><br><span class="line"># --threads线程数</span><br><span class="line"># -q表示reads比对质量选择，MAPQ，默认0;</span><br><span class="line"># -Q表示reads碱基对质量选择，默认13</span><br><span class="line"># -O表示输出格式,u表示未压缩bcf格式;</span><br><span class="line"># -f参考序列位置</span><br><span class="line">## bcftools call参数</span><br><span class="line"># --threads线程;</span><br><span class="line"># -v只输出变异位点;</span><br><span class="line"># m为克服-c调用模型中已知的局限性(与-c冲突)而设计的多等位和罕见变异调用的替代模型;</span><br><span class="line"># -O输出文件格式v未压缩vcf;</span><br><span class="line">## bcftools filter筛选变异;-i只保留后面条件的;-s对不符合的变异打上标签</span><br><span class="line">$ awk -F &quot;\t&quot; &apos;&#123;if($1~/#/)&#123;print&#125;else if($7~/PASS/)&#123;print&#125;&#125;&apos; raw.tmp.vcf &gt; var.flt.vcf</span><br><span class="line"># 将标为低质量的变异去掉</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有几个点值得讨论一下，首先是mpileup的-q参数，这个和之前提到的samtools view的-q是一样的，前面的文章有大篇幅说过这个MAPQ的数值，20翻译过来的意思其实就是比对正确率99%。<br><br>&emsp;&emsp;filter中的-s是软过滤的意思，就是把不符合后面条件的variations打上标签，但不过滤掉；-g，-G这对参数是说，indel附近的indel或snp是不准确的，大多是假阳性，过滤掉，这里我设的10bp，这个值还是比较合理的；-i是保留后面符合条件的变异，刚好和-e相反，两者选其一，我这里用的-i编写过滤表达式<br><br>&emsp;&emsp;&emsp;&emsp;QUAL：基于Phred格式的表示ALT的质量，也可以理解为可靠性；可以理解为所call出来的变异位点的质量值。Q=-10lgP，Q表示质量值；P表示这个位点发生错误的概率。因此，如果想把错误率从控制在90%以上，P的阈值就是1/10，那lg（1/10）=-1，Q=（-10）*（-1）=10。同理，当Q=20时，错误率就控制在了0.01。这个参数其实和mpileup的-Q是重复的。<br><br>&emsp;&emsp;&emsp;&emsp;DP是碱基的覆盖深度，一般很多公司和课题组会选择10，但我这里选择的是6，本着宽进严出的原则，保留更多的阳性variations，10也是没有关系的。<br><br>&emsp;&emsp;&emsp;&emsp;MQ不同于MAPQ，是RMS Mapping Quality，公式定义如下：q指的是比对到这个参考基因组碱基上的比对质量，即MAPQ。参考之前说的，MAPQ设置为20，假设每个碱基的MAPQ都是20，则MQ为20。<br></p>
<p><img src="/2019/06/18/WGS分析笔记（4）- Call SNVs indels/MQ.png" alt="MQ"><br>&emsp;&emsp;&emsp;&emsp;参考上一篇里的MAPQ分布可以看到，使用bwa mem后，其实大多数的reads的MAPQ都在60，这样的话，MQ最好也就是60，但是在40有一个小突起，对于MQ的筛选，大家的选择可以酌情而定，50是一个大家使用较多的阈值点。<br><br><img src="/2019/06/18/WGS分析笔记（4）- Call SNVs indels/MAPQ%E5%88%86%E5%B8%83.png" alt="MAPQ分布图"><br><img src="/2019/06/18/WGS分析笔记（4）- Call SNVs indels/MAPQ%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83%E6%9B%B2%E7%BA%BF.png" alt="MAPQ累积分布曲线"><br>&emsp;&emsp;&emsp;&emsp;DP4分别是正反链上REF和ALT的深度，我用“DP4[2]+DP4[3]&gt;4”筛选ALT的深度至少是5的variations。<br></p>
<p>&emsp;&emsp;那么，以上的脚本其实是符合单个样本进行分析的，但如果是家系样本进行分析，其实是有问题的，因为在call这一步的时候用-v参数只输出变异位点，在获得了三个人的vcf文件进行merge的时候，对于一些变异（这些变异只存在于三个人的某一个或某两个），你就不知道不存在的那个人身上，是因为无变异还是没有覆盖到reads。这不利于做trio分析。那么要克服这个问题只需要去掉-v参数即可。<br></p>
<p>&emsp;&emsp;然后进行merge，是在完成了一个家系的call snp/indel以后。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bgzip -c -f -@ 12 var.flt.vcf &gt; var.vcf.gz</span><br><span class="line"># 进行文件压缩;-c不改变内容; -f强制输出，存在就覆盖;-@线程数</span><br><span class="line">$ bcftools index -t var.vcf.gz</span><br><span class="line"># 建立索引，merge需要; -t建立tbi格式索引</span><br><span class="line">$ bcftools merge -Ov --force-samples -l file.list -o merge.var.vcf </span><br><span class="line"># 进行合成，-O输出文件格式,v表示vcf格式文件;</span><br><span class="line"># --force-samples，对于重名样本强制合成;-o输出文件</span><br><span class="line"># -l包含文件名的文件，一行一个文件名，将先证者放在第一位</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之后可以用bcftools对结果做一下统计处理<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 统计结果plot-vcfstats</span><br><span class="line">$ bcftools stats -F/your/path/of/reference -s - merge.var.vcf &gt;  merge.var.vcf.stats &amp;&amp; \</span><br><span class="line">$ plot-vcfstats merge.var.vcf.stats -p vars_output</span><br><span class="line"># plot-vcfstats程序在bcftools下的misc目录中</span><br></pre></td></tr></table></figure>

<h3 id="DeepVariant"><a href="#DeepVariant" class="headerlink" title="DeepVariant"></a>DeepVariant</h3><p>&emsp;&emsp;谷歌提供了分别适用于WGS和WES的脚本，可供大家参考。我亲测了一下这个软件，速度有点慢……完全没有谷歌自己描述的那么快，做为尝鲜吧，把当时的脚本放上来，这里要特别感谢师姐的指导！虽然最后我也没打算用这个软件完成我的课题吧。<br><br>&emsp;&emsp;&emsp;&emsp;<a href="https://github.com/google/deepvariant/tree/r0.7/scripts" target="_blank" rel="noopener">https://github.com/google/deepvariant/tree/r0.7/scripts</a><br>&emsp;&emsp;Deepvariant无需安装，直接拉docker下来就行，不然要是安装，这个环境配置怕是要折磨死人的。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># docker安装，仅针对ubuntu用户</span><br><span class="line">	$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common </span><br><span class="line">	$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">	$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">	$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br><span class="line">	$ sudo apt-get update</span><br><span class="line">	$ sudo apt-get install docker-ce</span><br><span class="line">	$ sudo docker run hello-world</span><br><span class="line">	$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;拉取一下docker就可以使用deepvariant了<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull dajunluo/deepvariant</span><br><span class="line">$ sudo docker images</span><br><span class="line">$ sudo docker run -it dajunluo/deepvariant:latest</span><br><span class="line">$ sudo docker run -it --name deepvariant -v /you/path/of/refrence/dir/:/home/ref_hg19 -v /home/biowork/:/home/biowork dajunluo/deepvariant</span><br><span class="line"># -v是把我本地的数据对接到docker环境里，这个请自行根据需要对接</span><br><span class="line">$ nohup python /home/bin/make_examples.zip --mode calling --ref /you/path/of/refrence --reads //you/path/of/bam --examples example.gz &gt; 1.log &amp;</span><br><span class="line">$ nohup python /home/bin/call_variants.zip --outfile call_variants_output.gz --examples example.gz --checkpoint /home/models/model.ckpt &gt; 2.log &amp;</span><br><span class="line">$ nohup python /home/bin/postprocess_variants.zip --ref /you/path/of/refrence --infile call_variants_output.gz  --outfile output.vcf.gz &gt; 3.log &amp;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之后便可以用bcftools或者gatk进行merge，对于这一步可以参考上面的gatk链接或者bcftools步骤。<br></p>
<hr>
<p>&emsp;&emsp;到了这一步就可以完了么？显然不是，你用上述两个方法或者参考黄老师的脚本用gatk得到的结果，如果你仔细看，就会发现。<br><br><img src="/2019/06/18/WGS分析笔记（4）- Call SNVs indels/vcf.png" alt="vcf示例"><br>&emsp;&emsp;这是什么鬼，这又是什么鬼，为什么有那么多的多等位位点，你要是去统计，会发现这样的多等位位点还挺多的，所以你还不能直接过滤。对于这些变异我们一般是不会考虑嵌合的，因为平均30X的WGS是没法检测出嵌合体的。那么对于这样的位点怎么去考虑分析呢？<br><br>&emsp;&emsp;比较便捷的方法就是用bcftools里面的norm工具了。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bgzip -c -f -@ 12 merge.var.vcf &gt; merge.var.vcf.gz</span><br><span class="line"># 进行文件压缩;-c不改变内容; -f强制输出，存在就覆盖;-@线程数</span><br><span class="line">$ bcftools index -t merge.var.vcf.gz</span><br><span class="line"># 建立索引, -t建立tbi格式索引</span><br><span class="line">$ bcftools norm -Ov -m-any -f /you/path/of/refrence merge.var.vcf.gz &gt; norm.vcf</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样，多等位位点就变成了二等位位点了，便于后续的分析。今天的内容就到这里了，下一篇就是注释以及各种过滤了。<br></p>
<hr>
<p>&emsp;&emsp;水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！<br></p>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/18/WGS分析笔记（3）- bam文件的处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/18/WGS分析笔记（3）- bam文件的处理/" class="post-title-link" itemprop="url">WGS分析笔记（3）- bam文件的处理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 12:50:51" itemprop="dateCreated datePublished" datetime="2019-06-18T12:50:51+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-22 23:35:25" itemprop="dateModified" datetime="2019-06-22T23:35:25+08:00">2019-06-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS/" itemprop="url" rel="index"><span itemprop="name">我的WGS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>上一篇记录了mapping这一步的软件选择，也讲到了对于sam文件如何考虑MAPQ的过滤，这篇我主要想记录一下bam文件在进行call variation之前的处理。<br></p>
</li>
<li><p>包括MAPQ的筛选等都是这个处理的一部分。<br></p>
</li>
<li><p>既然要处理bam文件，不得不提bam文件的格式。<br></p>
</li>
<li><p>处理生物信息的数据时会发现，文件有各种各样的格式，眼花缭乱，这也是我一开始接触课题接触分析流程时的感受。但是多和这些文件打交道以后，会发现，大多数的不同格式的文件其本质都是文本文件，为了某种特殊的处理或记录需要，按一定的规则记录信息。包括之前接触的fasta、fastq文件，也包括sam文件，以后后面步骤会接触到的vcf文件等。<br></p>
</li>
<li><p>bam文件是sam文件的二进制格式，这里贴一张图，来说明一下为什么要转换成bam文件来处理。<br><br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/%E5%A4%A7%E5%B0%8F.png" alt="文件大小"></p>
</li>
<li><p>可以看到，不经过处理的sam文件是非常大的，非常不利于存储和处理，而转换格式后的bam文件小很多，所以很多处理软件也是针对bam文件进行开发的。<br></p>
</li>
<li><p>包括bwa，bowtie2的输出文件，都是sam文件，但是sam文件具体是什么样子的，我这里不会展开来讲，一是因为<a href="http://samtools.github.io/hts-specs/SAMv1.pdf" target="_blank" rel="noopener">官网说明书</a>已经说的很清楚了，二是因为你随手一个百度、谷歌（如果你翻得动墙）就有很多很多的人发帖介绍，而内容大体都是类似的，我自认为也没有什么能比他们讲得更好的。但是了解这个文件的内容确实是非常重要的。<br></p>
</li>
<li><p>以<code>@</code>开头的行记录了header信息，之后的行记录了每个reads的mapping信息，一般对于这样的sam文件我们要做的处理大体就是先转换为bam文件，进行sort，再进行merge，最后mark duplicates，并建立索引。接下来我将一步步介绍怎么去处理，以及为什么我是这么处理的。<br></p>
</li>
<li><p>在开始之间先使用<a href="http://www.htslib.org/doc/samtools.html" target="_blank" rel="noopener">samtools</a>对参考序列进行索引建立，作用是用于samtools软件快速识别，这一步也是一劳永逸的，只要不把索引文件删除。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ samtools faidx re.fa</span><br><span class="line"># 得到索引文件：re.fa.fai</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先是把sam文件转换成bam文件，我们通过samtools view来实现，代码如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ samtools view -S in.sam -b &gt; out.bam</span><br><span class="line">$ samtools view -b in.bam -S &gt; out.sam</span><br></pre></td></tr></table></figure>
</li>
<li><p>但实际上，在真正的操作中，我们是不会保留sam文件的，甚至是不会产生sam文件的，因此，我们通常这么来写命令。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bwa mem -t 12 -M -R &quot;@RG\tID:W2018001\tPL:ILLUMINA\tLB:W2018001\tSM:W2018001&quot; /your/path/of/reference/ucsc.hg19.fasta 1.fq.gz 2.fq.gz | samtools view -q 1 -Shb - &gt; W2018001.bam</span><br><span class="line"># 关于“|”之前的我就不解释了，看我上一篇简书</span><br><span class="line"># -q 1 ：筛选MAPQ用的，意为保留MAPQ &gt;= 1的记录，上一篇简书中讨论过关于MAPQ的由来和分布，这里用“1”也是保险起见，但实际上没啥区别，后期处理上（vcf处理），我们会以更严格的阈值去过滤</span><br><span class="line"># -h ：表示保留header信息</span><br><span class="line"># -S，-b：表示格式，S指的是sam格式，b指的是bam格式</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样操作的好处是直接可以得到bam文件，不必占用大量的空间存储sam文件。如果你实在是需要sam文件也可以转换回去，但如果你只是想查看一下，也可以通过以下方式实现。还是很方便的。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ samtools view -h xxx.bam | less</span><br></pre></td></tr></table></figure>
</li>
<li><p>在测序的时候序列是随机打断的，所以reads也是随机测序记录的，进行比对的时候，产生的结果自然也是乱序的，为了后续分析的便利，将bam文件进行排序。事实上，后续很多分析都建立在已经排完序的前提下。关于排序可以通过以下命令完成。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ samtools sort -@ 6 -m 4G -O bam -o sorted.bam W2018001.bam</span><br><span class="line"># @：线程数</span><br><span class="line"># m：每个线程分配的最大内存</span><br><span class="line"># O：输出文件格式</span><br><span class="line"># o：输出文件的名字</span><br><span class="line"># 输入文件放在最后</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要做的是merge，这个不是所有的样本都需要做的！！！<br></p>
</li>
<li><p>之前有提到，WGS的数据比较大，对于一个样本可能有多对文件，一般有两个思路，一个是先对原始的fastq文件进行merge，一个是对后面的bam文件进行merge。那么我选用的是后者。实现脚本如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ samtools merge -@ 6 -c sorted.merged.bam *.sorted.bam</span><br><span class="line"># @：线程数</span><br><span class="line"># c：当输入bam文件的header一样时，最终输出一个header</span><br><span class="line"># 当然也可以用-h file，定义你想要的header，file里的内容就是sam文件header的格式</span><br><span class="line"># 第一个bam是输出的文件名，后面排列输入的文件名，我这里用了通配符‘*’，要保证该目录下‘.sorted.bam’结尾的都是你要输入的文件</span><br><span class="line"># 当然也可以用-b file，file文件里罗列要merge的文件名，一行一个文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>下一步就是remove duplicates，为什么要进行这一步呢？先来说一下测序，我们都知道人的基因组是很庞大的（约30亿个碱基对），在测序的时候，先会把基因组的DNA序列通过超声震荡随机打断成150bp的片段，那么从概率上来讲，出现同样的片段（开始和结束位置都一样）的几率是极小的。但是由于PCR对某些位置有偏好的扩增，会导致一些一模一样的reads存在。这些reads其实是一个片段的扩增导致的，多出来的reads，对该区段突变的判断是没什么贡献的，如果不加处理，反而会大大增加那个位置的深度，导致某些结果的不准确。<br></p>
</li>
<li><p>如下图所示，箭头所指的reads，就是duplicates，我们一般采取的策略是标记或者去除，这样的话，下一步call variation的时候会不考虑这些reads。<br><br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/duplicates2.png" alt="duplicates(from bing)"></p>
</li>
<li><p>关于这一步，有很多软件可以实现，比较多用的是picard和samtools rmdup。我这里用的是GATK包里集成的picard的MarkDuplicates。关于picard和samtools rmdup的效果其实大家可以自己试一下，我很早之前做过的试验是，samtools rmdup速度很快，但是去除的效果稍差。大家用的最多的也是picard。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar /you/path/of/gatk/gatk-package-4.0.10.1-local.jar \</span><br><span class="line">	MarkDuplicates \</span><br><span class="line">	-INPUT sorted.merged.bam \</span><br><span class="line">	-OUTPUT sorted.merged.markdup.bam \</span><br><span class="line">	-METRICS_FILE markdup_metrics.txt</span><br><span class="line"># 也可以加上“REMOVE_DUPLICATES=true”来去除掉这些duplicates，不然就只是标记</span><br></pre></td></tr></table></figure>
</li>
<li><p>到了这一步基本上就处理的差不多了，可以进行call variation了，但是这里还有一步建立索引，这十分的重要！！！！<br></p>
</li>
<li><p>必须对bam文件进行排序后，才能进行index，否则会报错。建立索引后将产生后缀为.bai的文件，用于快速的随机处理。很多情况下需要有bai文件的存在，特别是显示序列比对情况下。建立索引很简单。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ samtools index sorted.merged.markdup.bam</span><br></pre></td></tr></table></figure>
</li>
<li><p>到了这一步就基本上完事了，可以通过IGV或tview来查看情况，这都需要建立索引，且索引文件和bam文件在同一个目录下。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ samtools tview sorted.merged.markdup.bam re.fa</span><br><span class="line"># 可以用-p chr:pos（加在tview和sorted.merged.markdup.bam之间）指定要查看的位置</span><br><span class="line"># 也可以进去后用敲‘g’输入`chr10:10,000,000&apos; 或 `=10,000,000&apos;查看指定的位置，敲&apos;?&apos;了解更多说明，q退出</span><br></pre></td></tr></table></figure>
</li>
<li><p>下图就是效果了，用“？”，打开左边的帮助界面，其中圆点表示正链比对，逗号表示负链比对，星号表示插入。不同的颜色代表不同的含义，具体怎么调看帮助框。要是觉得不好看的话可以用IGV查看。IGV的效果就是上图duplicates的效果。<br><br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/tview.png" alt="tview"></p>
</li>
<li><p>同时对于得到的bam文件也可以进行一下查看，对于bam的统计软件就更多了，我这里网罗了一些帖子上的推荐以及我自己日常使用的软件，感兴趣的可以自己去下载来使用一下。<br></p>
</li>
</ul>
<p>###<a href="http://www.htslib.org/doc/samtools.html" target="_blank" rel="noopener">samtools</a></p>
<ul>
<li><p>这是个强大的软件，也自带一些统计工具，上篇简书其实我们就用到了，主要是四个：idxstats，depth，stats，flagstat<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ samtools depth sorted.merged.markdup.bam</span><br><span class="line">	示例结果</span><br><span class="line">		#chr    pos depth</span><br><span class="line">		chr1    1   5</span><br><span class="line">	结果可以得到染色体名称、位点位置、覆盖深度</span><br><span class="line">	-a:输出所有位点，包括零深度的位点</span><br><span class="line">	-a -a --aa:完全输出所有位点，包括未使用到的参考序列</span><br><span class="line">	-b FILE：计算BED文件中指定位置或区域的深度</span><br><span class="line">	-f FILE：指定bam文件</span><br><span class="line">	-l INT:忽略小于此INT值的reads</span><br><span class="line">	-q INT：只计算碱基质量大于此值的reads</span><br><span class="line">	-Q INT：只计算比对质量大于此值的reads</span><br><span class="line">	-r CHR:FROM-END：只计算指定区域的reads</span><br><span class="line">$ samtools idxstats sorted.merged.markdup.bam  #需要预先进行sort和index</span><br><span class="line">	示例结果</span><br><span class="line">		#ref    sequence_length mapped_reads    unmapped_reads</span><br><span class="line">		chr1    195471971    6112404    0</span><br><span class="line">	结果可看出，分别统计染色体名称、序列长度、mapped数目，以及unmapped数目</span><br><span class="line">$ samtools flagstat sorted.merged.markdup.bam</span><br><span class="line">	示例结果：</span><br><span class="line">		20607872 + 0 in total (QC-passed reads + QC-failed reads) #总共的reads数</span><br><span class="line">		0 + 0 duplicates #重复reads的数目</span><br><span class="line">		19372694 + 0 mapped (94.01%:-nan%) #总体上reads的数目以及匹配率；可能有有小偏差</span><br><span class="line">		20607872 + 0 paired in sequencing  #paired reads的数目</span><br><span class="line">		10301155 + 0 read1 #reads1的数目</span><br><span class="line">		10306717 + 0 read2 #reads2的数目</span><br><span class="line">		11228982 + 0 properly paired (54.49%:-nan%) #完美匹配的reads数：比对到同一条参考序列，并且两条reads之间的距离符合设置的阈值</span><br><span class="line">		18965125 + 0 with itself and mate mapped#两条都比对到参考序列上的reads数，但是并不一定比对到同一条染色体上</span><br><span class="line">		407569 + 0 singletons (1.98%:-nan%)#只有一条比对到参考序列上的reads数，和上一个相加，则是总的匹配上的reads数。</span><br><span class="line">		3059705 + 0 with mate mapped to a different chr#两条分别比对到两条不同的染色体的reads数</span><br><span class="line">		1712129 + 0 with mate mapped to a different chr (mapQ&gt;=5)#两条分别比对到不同染色体的且比对质量值大于5的数量</span><br><span class="line">	# 说明：</span><br><span class="line">		1.bwa的mem比对方法生成的bam文件保留sencondly比对的结果。所以使用flagstat给出的结果会有偏差。</span><br><span class="line">		2.每一项统计数据都由两部分组成，分别是QC pass和QC failed，表示通过QC的reads数据量和未通过QC的reads数量。以“PASS + FAILED”格式显示</span><br><span class="line">$ samtools stats sorted.merged.markdup.bam</span><br><span class="line"> 	# 对bam文件进行详细的统计，也可只统计某一染色体的某一区域chr：from-to</span><br><span class="line">	结果包括：</span><br><span class="line">		Summary Numbers,raw total sequences,filtered sequences, reads mapped, reads mapped and paired,reads properly paired等信息</span><br><span class="line">		Fragment Qualitites #根据cycle统计每个位点上的碱基质量分布</span><br><span class="line">		Coverage distribution #深度为1，2，3，，，的碱基数目</span><br><span class="line">		ACGT content per cycle #ACGT在每个cycle中的比例</span><br><span class="line">		Insert sizes #插入长度的统计</span><br><span class="line">		Read lengths #read的长度分布</span><br><span class="line">	stats出来的结果可以使用plot-bamstats来画图(samtools目录下misc目录中)</span><br><span class="line">	$ plot-bamstats -p outdir/ sorted.merged.markdup.bam.stats</span><br></pre></td></tr></table></figure>
</li>
<li><p>下图就是plot-bamstats操作的输出结果了，可以看到有很多的图。效果还是很好的。<br><br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/plot-bamstats.png" alt="plot-bamstats"></p>
</li>
<li><p>更多关于samtools的工具以及上文提到的工具的其余参数请参考官网：<a href="http://www.htslib.org/doc/samtools.html" target="_blank" rel="noopener">http://www.htslib.org/doc/samtools.html</a><br></p>
</li>
</ul>
<p>###<a href="https://rseqc.sourceforge.net/" target="_blank" rel="noopener">RSeQC</a></p>
<ul>
<li>这也是上篇中提到过的，所以安装方式和使用就不赘述了，其实里面还有一些其余实用的工具，当然这款软件的最初使用对象是RNA-seq，但并不影响使用，有些工具是通用的，有一点要注意的是，bam_stat.py里的unique mapping的默认阈值是MAPQ&gt;=30，当然可以通过参数来修改，这个在结果的理解上大家要注意。<br></li>
</ul>
<p>###<a href="https://bedtools.readthedocs.io/en/latest/" target="_blank" rel="noopener">bedtools</a></p>
<ul>
<li><p>这是一个经常使用也很实用的软件，我经常会用来截取bam然后在igv上看突变的情况，师姐推荐其中的mutlicov进行覆盖度的统计。我粗略的看了一下bedtools的说明书，用于coverage统计的应该还有coverage，genomecov。感兴趣的可以尝试一下。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bedtools:</span><br><span class="line">	$ wget https://github.com/arq5x/bedtools2/releases/download/v2.27.1/bedtools-2.27.1.tar.gz</span><br><span class="line">	$ tar -zxvf bedtools-2.27.1.tar.gz</span><br><span class="line">	$ cd bedtools2</span><br><span class="line">	$ make</span><br><span class="line"># 脚本在bin/下的bedtools</span><br><span class="line"># Ubuntu用户也可以使用下述命令来下载：</span><br><span class="line">$ sudo apt-get install bedtools</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取bam文件，查看igv可以用以下命令：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bedtools intersect -a sorted.merged.markdup.bam -b region.sorted.bed &gt; target_reads.bam &amp;&amp; samtools index target_reads.bam </span><br><span class="line">#其中bed文件的格式可以参考：</span><br><span class="line">#染色体号  起始位置  终止位置</span><br><span class="line">chr1	226173187	226173247</span><br><span class="line">#用&quot;\t&quot;分隔</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>###<a href="https://software.broadinstitute.org/gatk/" target="_blank" rel="noopener">GATK</a></p>
<ul>
<li>GATK不仅可以call variation，里面还包含了很多其他用途的工具包，其中有一个工具叫DepthOfCoverage，可以统计depth和coverage，但是在panel中比较适用，因为有bed范围，且比较小。这个工具的速度是比较慢的，要在全基因组上做不太现实。所以我本人也没去使用。<br></li>
</ul>
<p>###<a href="http://bamstats.sourceforge.net/" target="_blank" rel="noopener">BAMStats</a></p>
<ul>
<li>一款比较早的bam统计软件，没用过，但是看说明使用是极其简单了，说一下怎么安装。感兴趣的可以自己试一下，很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://jaist.dl.sourceforge.net/project/bamstats/BAMStats-1.25.zip</span><br><span class="line">$ unzip BAMStats-1.25.zip</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>###<a href="https://github.com/shiquan/bamdst" target="_blank" rel="noopener">bamdst</a></p>
<ul>
<li><p>一款简单好用的深度统计软件。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/shiquan/bamdst.git</span><br><span class="line">$ cd bamdst/</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装好后，需要准备.bed文件及.bam文件，以软件提供的MT-RNR1.bed和test.bam为例，使用命令如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bamdst -p MT-RNR1.bed -o ./ test.bam</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出的结果包含7个文件，为：<br></p>
<ul>
<li>-coverage.report</li>
<li>-cumu.plot</li>
<li>-insert.plot</li>
<li>-chromosome.report</li>
<li>-region.tsv.gz</li>
<li>-depth.tsv.gz</li>
<li>-uncover.bed</li>
</ul>
</li>
<li><p>主要看一下coverage.report文件，里面包含了大量信息。<br></p>
</li>
</ul>
<p>###<a href="http://qualimap.bioinfo.cipf.es/doc_html/index.html" target="_blank" rel="noopener">qualimap</a></p>
<ul>
<li><p>这算是压轴了吧，这个软件是我师姐推荐的，安装使用都比较容易，给出的是PDF或HTML的报告，报告中的信息特别丰富，还有一堆的图，所以在我自己的脚本中也会对每个样本使用该软件统计，简述一下安装和使用。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 第一步：下载</span><br><span class="line">$ mkdir qualimap</span><br><span class="line">$ cd qualimap</span><br><span class="line">$ wget https://bitbucket.org/kokonech/qualimap/downloads/qualimap_v2.2.1.zip</span><br><span class="line">$ unzip qualimap_v2.2.1.zip</span><br><span class="line">$ cd qualimap_v2.2.1</span><br><span class="line"># 第二步安装相关的软件</span><br><span class="line"># java</span><br><span class="line"># 这个应该都有，这里就是贴一下官网的步骤</span><br><span class="line">$ sudo apt-get install openjdk-6-jre</span><br><span class="line"># R</span><br><span class="line"># 官网上也有，我贴的是自己以前安装的记录</span><br><span class="line">$ apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9</span><br><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install r-base</span><br><span class="line">$ apt install r-base-core</span><br><span class="line"># R包安装，两个方法，第一个听说容易报错，我用的是第二个</span><br><span class="line">$ Rscript scripts/installDependencies.r</span><br><span class="line"># 或</span><br><span class="line">$ R</span><br><span class="line">&gt; install.packages(&quot;optparse&quot;)</span><br><span class="line">&gt; source(&quot;http://bioconductor.org/biocLite.R&quot;)</span><br><span class="line">&gt; biocLite(c(&quot;NOISeq&quot;, &quot;Repitools&quot;, &quot;Rsamtools&quot;, &quot;GenomicFeatures&quot;, &quot;rtracklayer&quot;))</span><br><span class="line">&gt; q()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用也简单，主要分为带gtf文件和不带gtf文件，全基因组的话一般不带gtf文件，然后bamqc其实也只是这个软件中的一个工具，其他的工具感兴趣的也可以看看。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ qualimap bamqc -bam sorted.merged.markdup.bam  --java-mem-size=20G -c -nt 16 -outdir bamqc -outfile bamqc.pdf -outformat PDF:HTML</span><br><span class="line"># 参数也没有什么特别要注意的，基本上默认的就可以</span><br></pre></td></tr></table></figure>
</li>
<li><p>找了一个示例结果，发现有23页，我这里就不贴了，大家可以自己尝试一下。<br></p>
</li>
<li><p>最后贴两张图，是我自己写的脚本得到的深度分布，累积曲线以及覆盖率，因为是自己写的，所以比较糙，横纵坐标标题什么的一律没写。<br><br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/depth.png" alt="depth"></p>
</li>
<li><p>上图可以看到，深度分布还是比较正态的，最多的30X左右，至于左边0X为什么这么高，是因为参考基因组有些位置就是N，还有一些位置就是我的样本没有覆盖到。<br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/depth.cdf.png" alt="depth.cdf"></p>
</li>
<li><p>上图可以看到，小于10X的数据的不到2%，超过50%的数据都是高于30X的，还是不错的。<br><img src="/2019/06/18/WGS分析笔记（3）- bam文件的处理/coverage.png" alt="coverage"></p>
</li>
<li><p>上图我按不同的染色体进行统计覆盖率，去掉了其余的一些未知染色体位置的序列上的信息（这个信息具体要了解参考基因组的特性，比如有些序列目前能明确在人身上，却不知道具体在哪个染色体等，这些信息也是包含在参考基因组中的，仔细看参考基因组会发现，除了22条常染色体，2条性染色体，还有很多其他的序列），这个覆盖率并不是我想想的那般全体高于99%，也没公司给的报告描述的那么好，主要是因为MAPQ的过滤导致了这样的结果，但是总体的覆盖率还可以。</p>
</li>
<li><p>水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://tongshiyuan.github.io/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TongShiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taro">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/" class="post-title-link" itemprop="url">WGS分析笔记（2）- bwa vs bowtie2</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 11:10:20" itemprop="dateCreated datePublished" datetime="2019-06-18T11:10:20+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-22 23:35:17" itemprop="dateModified" datetime="2019-06-22T23:35:17+08:00">2019-06-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/我的WGS/" itemprop="url" rel="index"><span itemprop="name">我的WGS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>在进行正式的mapping记录之前，先记录一下bwa与bowtie2在mapping这个环节的情况。<br></p>
</li>
<li><p>一般对于WGS结果的mapping，一般推荐的软件有两款，分别是bwa和bowtie2，大多数的公司报告或者网上的教程，我所看到的都是使用bwa进行比对的，这里，我来进行一下两个软件的对比。<br></p>
</li>
<li><p>实验对象还是之前文章提到的那个样本的数据，我只取用其中的一对数据进行mapping并比较。<br></p>
</li>
<li><p>比较之前先进行一下软件安装、参考序列下载并建立索引<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bowtie2</span><br><span class="line">	$ wget https://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.3.4.3/bowtie2-2.3.4.3-linux-x86_64.zip</span><br><span class="line">	# https://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.3.4/bowtie2-2.3.4-linux-x86_64.zip</span><br><span class="line">	$ unzip bowtie2-2.2.9-linux-x86_64.zip</span><br><span class="line">	$ ln -sf /biosoft/bowtie2-2.3.4.3-linux-x86_64/bowtie2 /home/shiyuantong/bin/bowtie2</span><br><span class="line">BWA:</span><br><span class="line">	$ wget https://sourceforge.net/projects/bio-bwa/files/bwa-0.7.17.tar.bz2</span><br><span class="line">	$ tar -jxvf bwa-0.7.17.tar.bz2 # x extracts, v is verbose (details of what it is doing), f skips prompting for each individual file, and j tells it to unzip .bz2 files</span><br><span class="line">	$ make</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于安装这里有一些需要注意的地方！！！！！<br></p>
</li>
<li><p>首先是bowtie2，建议大家使用2.3.4的下载链接，我在下载的时候最新版是2.3.4.3，但是在使用的出现了报错！！！！！<br></p>
</li>
<li><p>报错的内容如下（当时没截图）：<br><br>&emsp;&emsp;&emsp;&emsp;Segmentation fault (core dumped) (ERR): bowtie2-align exited with value 139</p>
</li>
<li><p>这个报错只会出现在批量处理的脚本中，对单个样本的处理并没有影响，但是实际使用的时候，大家都是批量处理样本，怎么可能一个样本一个命令，因此推荐2.3.4的版本，当然，下面的比较不会涉及这个问题。<br></p>
</li>
<li><p>还有就是BWA了，这个软件ubuntu用户也可以直接使用<code>sudo apt-get install bwa</code>命令进行安装，我看了一下，两种方法的版本是一致的，都是0.7.17。<br></p>
</li>
<li><p>然后是参考序列，这里直接使用ucsc的hg19，下载与建立索引方式如下，根据自己的需要调整目录<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hg19：</span><br><span class="line">	$ cd /your/path/of/reference/</span><br><span class="line">	$ wget http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz</span><br><span class="line">	$ tar zvfx chromFa.tar.gz</span><br><span class="line">	$ cat *.fa &gt; hg19.fa</span><br><span class="line">	$ rm chr*.fa</span><br><span class="line">建立bwa索引：</span><br><span class="line">	$ bwa index -a bwtsw  hg19.fa</span><br><span class="line"> 	# 产生.bwt .pac .ann .amb .sa五个新文件</span><br><span class="line">	# -a：两种构建index算法，bwtsw以及is，bwtsw适用大于10MB的参考基因组，比如人，is适用于小于2GB的数据库，是默认的算法，速度较快，需要较大的内存，</span><br><span class="line">	# -p：输出数据库的前缀，默认与输入文件名一致，这里我没有加这个参数，直接输出到当前目录</span><br><span class="line">建立bowtie2索引：</span><br><span class="line">	$ bowtie2-build hg19.fa hg19.fa</span><br><span class="line">	# bowtie2-build命令在安装bowtie2的目录下找到</span><br><span class="line">	# 第一个hg19.fa代表输入的参考序列</span><br><span class="line">	# 第二个hg19.fa代表输出的索引文件前缀</span><br><span class="line">	# 产生六个.bt2新文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述程序建立索引速度较慢，尤其是bowtie2，但是一次建好，一劳永逸，请大家耐心等待，也可以放在后台，防止终端突然的中断。<br></p>
</li>
<li><p>建立好索引就可以直接开始比对了，以下是我的比对程序，都开了24线程，用<code>nohup …… &amp;</code>放在后台运行，用<code>time</code>记录时间。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nohup time bowtie2 -p 24 -x /your/path/of/reference/ucsc.hg19.fasta --rg-id W2018001 --rg PL:ILLUMINA --rg LB:W2018001 --rg SM:W2018001 -1 W2018001_NZTD180602206_HCV5MDMXX_L1.cleaned.1.fq.gz -2 W2018001_NZTD180602206_HCV5MDMXX_L1.cleaned.2.fq.gz -S W2018001.bowtie2.sam &gt; W2018001.bowtie2.log &amp;</span><br><span class="line">$ nohup time bwa mem -t 24 -M -R &quot;@RG\tID:W2018001\tPL:ILLUMINA\tLB:W2018001\tSM:W2018001&quot; /your/path/of/reference/ucsc.hg19.fasta W2018001_NZTD180602206_HCV5MDMXX_L1.cleaned.1.fq.gz W2018001_NZTD180602206_HCV5MDMXX_L1.cleaned.2.fq.gz 1&gt;W2018001.bwa.sam 2&gt;W2018001.bwa.log &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这一步会比较久，我也是经过漫长的半天等待终于迎来了结果，首先看一下速度吧。先前的脚本使用了<code>time</code>的命令，可以直接看到速度，在日志文件里。<br><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/%E6%97%B6%E9%97%B4%E5%AF%B9%E6%AF%94.png" alt="时间对比"></p>
</li>
<li><p>日志文件的最后两行就是<code>time</code>命令输出的结果，所以没有必要用<code>cat</code>查看，而且bwa的日志文件，要是用<code>cat</code>怕是屏幕要炸。图中可以看到两个红色的框，就是我标出来的时间。（其实我原来用<code>time</code>命令，结果不长这样的，这个结果不太利于观看，但是也能说明问题了）<br></p>
</li>
<li><p>很明显的可以看到半套全基因组的数据（我只用了样本一半的数据）bowtie2跑的更快一些，但其实大家不用纠结这个点。因为上一次我用24线程，一样的脚本一样的数据，跑bowtie2花了六个多小时，速度没有bwa快，同时以前在使用酵母的测序数据（数据量会比较小）的时候，明显发现bwa速度比bowtie2快，甚至在说法上你也会发现不同的人给你的说法是不一样的，有些人说bwa快有些人说bowtie2快，网上看帖子也没有一个十分明确的说法哪个速度快。这里大家完全可以用自己的数据和脚本跑一下，看看结果。<br></p>
</li>
<li><p>接下来我想看看比对效果，这里我先采用了samtools的flagstat分别进行统计，下面是安装samtools的步骤：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">samtools:</span><br><span class="line">	$ wget https://github.com/samtools/samtools/releases/download/1.9/samtools-1.9.tar.bz2</span><br><span class="line">	$ tar xvfj samtools-1.9.tar.bz2</span><br><span class="line">	$ cd samtools-1.9</span><br><span class="line">	$ ./configure --prefix=/where/to/install</span><br><span class="line">	$ make</span><br><span class="line">	$ make install</span><br><span class="line"># samtools其实我到现在为止装的最崩溃的软件之一了，因为在实际安装的时候你会发现它需要各种各样的库的支持，对于使用新机器的我，我基本是安装，报错缺什么库，安装缺的库，重新安装，这么折腾了一下午</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就是使用统计工具，其实很简单。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ samtools flagstat W2018001.bowtie2.sam &gt;W2018001.bowtie2.flagstat</span><br><span class="line">$ samtools flagstat W2018001.bwa.sam &gt;W2018001.bwa.flagstat</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个也需要花一点时间，但不会太长，看一下结果。<br><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/flagstat.png" alt="flagstat"></p>
</li>
<li><p>这个结果还是比较清楚的，bwa的结果比bowtie2稍稍好一点。但相差不是很大，所以对于这两个软件，一直是公说公有理，婆说婆有理，这里我用另一个软件对结果进行统计，再进行对比试试。<br></p>
</li>
<li><p><a href="https://rseqc.sourceforge.net" target="_blank" rel="noopener">RSeQC</a>是一个功能强大的软件，里面有很多实用的小工具，其中的bam_stat就是一个实用的bam/sam结果统计工具，安装方式也是相当简单了，就是一个python的包，支持python2.x和python3.x，这里我选用python3的pip来安装，因为本人习惯使用python3。<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install RSeQC</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用和结果如下，由于我这个sam文件比较大，运行起来比较慢，所以我开了俩终端。<br><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bam_stat.png" alt="bam_stat"></p>
</li>
<li><p>其实我最想看的unique mapping的reads，因为后期为了降低假阳性，在处理bam文件的时候会选择unique mapped的reads，但是在查看说明书无果后，找遍论坛没有找到一个能够说服我的筛选unique mapped的方式。<br></p>
</li>
<li><p>有这么几个方式，一个说是看tag，但是bwa的结果，你仔细看说明书和结果，会发现，这个tag并没有什么用，bowtie2倒是还可以。<br></p>
</li>
<li><p>第二个也是说的比较多的一个，看MAPQ。那么mapq是啥呢，我来贴几张图。<br></p>
</li>
</ul>
<p><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bowtie2%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="bowtie2的说明"></p>
<p><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/SAM%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="SAM的说明"></p>
<p><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/%E5%AE%98%E7%BD%91%E8%AF%B4%E6%98%8E.png" alt="官网说明"></p>
<ul>
<li>分别是sam格式官网的说明，bowtie2官网的说明，这两个说明的公式是一样的，都指向最后一个官网的说明。看到这个官网的公式，我直接就傻掉了，反正到现在也没推出个所以然来。但是前两张图就很好理解了。但是和很多人说的MAPQ&gt;=1就是unique mapping，我觉得是对不上的。对于这点我不多说，<a href="http://qiubio.com/archives/3321" target="_blank" rel="noopener">这里</a>的解释也是目前为止我最能接受的。<br></li>
<li>那上面那个结果，bam_stat，我在阅读源码后，发现是以MAPQ&gt;=30作为阈值来挑选是否unique的。由于bwa和bowtie2的mapq的计算方式不一样，这个结果其实并不可信。于是我写了一个脚本，看了一下mapq的分布情况。<br></li>
</ul>
<p><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bowtie2.png" alt="bowtie2"></p>
<p><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bwa.png" alt="bwa"></p>
<ul>
<li><p>这个图能说明什么呢，有待商榷。<br></p>
</li>
<li><p>这个时候再回过来看一下bowtie2的输出结果和大家说的bowtie2的筛选unique mapping的方法以及结果。<br><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bowtie2.log.png" alt="bowtie2.log"><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/bowtie2_tag.png" alt="bowtie2_tag"></p>
</li>
<li><p>其实到这里我也不知道该怎么办了，到现在还是不知道，bwa结果用mapq&gt;=1是否能得到unique mapping。这个结果对于后续分析影响有多大我不好说，至于怎么选择，我也不发表意见，不过在后续的筛选中，gatk给出的建议是mapq&gt;=40。<br></p>
</li>
<li><p>2019-1-9补充bwa结果，按mapq分布，分别计算&gt;=1,10,20,30的比例。为大家选择MAPQ作为筛选提供一个参考。<br><br><img src="/2019/06/18/WGS分析笔记（2）- bwa vs bowtie2/mapq%E5%88%86%E5%B8%83.png" alt="MAPQ比例"></p>
</li>
<li><p>但是回归主题，bwa和bowtie2，我决定选择bwa。<br></p>
</li>
<li><p>水平有限，要是存在什么错误请指出，可发送邮件至<a href="mailto:shiyuant@outlook.com" target="_blank" rel="noopener">shiyuant@outlook.com</a>！请大家多多批评指正，相互交流，共同成长，谢谢！！！<br></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
  
</div>
    <div>
      
    </div>
    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="TongShiyuan">
            
              <p class="site-author-name" itemprop="name">TongShiyuan</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/tongshiyuan" title="GitHub &rarr; https://github.com/tongshiyuan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/4450f2e08883" title="简书 &rarr; https://www.jianshu.com/u/4450f2e08883" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:shiyuant@outlook.com" title="E-Mail &rarr; mailto:shiyuant@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TongShiyuan</span>
<!--
  
-->
  
</div>

<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.2</div>



-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共33.2k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
